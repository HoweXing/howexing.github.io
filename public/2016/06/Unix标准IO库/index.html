<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>UNIX标准I/O库 | XZH</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="xingzhihao">
  
  
    <meta name="description" content="流和FILE对象文件I/O中，当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后续的I/O操作。而对于标准I/O库，它们的操作是围绕流进行的，当使用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。
标准I/O文件流可以用于单字节或多字节（宽）字符集。流的定向决定了所读写的字符是单字节还是多字节的。一个流被创建时是没有定向的，若在未定向的流上使用多字节I/O函数，则将">
  
  <meta name="description" content="流和FILE对象文件I/O中，当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后续的I/O操作。而对于标准I/O库，它们的操作是围绕流进行的，当使用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。
标准I/O文件流可以用于单字节或多字节（宽）字符集。流的定向决定了所读写的字符是单字节还是多字节的。一个流被创建时是没有定向的，若在未定向的流上使用多字节I/O函数，则将">
<meta property="og:type" content="article">
<meta property="og:title" content="UNIX标准I/O库">
<meta property="og:url" content="http://www.xzh.space/2016/06/Unix标准IO库/index.html">
<meta property="og:site_name" content="XZH">
<meta property="og:description" content="流和FILE对象文件I/O中，当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后续的I/O操作。而对于标准I/O库，它们的操作是围绕流进行的，当使用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。
标准I/O文件流可以用于单字节或多字节（宽）字符集。流的定向决定了所读写的字符是单字节还是多字节的。一个流被创建时是没有定向的，若在未定向的流上使用多字节I/O函数，则将">
<meta property="og:image" content="http://o877ej38d.bkt.clouddn.com/apue-5.2.PNG">
<meta property="og:updated_time" content="2016-06-21T15:12:39.607Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="UNIX标准I/O库">
<meta name="twitter:description" content="流和FILE对象文件I/O中，当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后续的I/O操作。而对于标准I/O库，它们的操作是围绕流进行的，当使用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。
标准I/O文件流可以用于单字节或多字节（宽）字符集。流的定向决定了所读写的字符是单字节还是多字节的。一个流被创建时是没有定向的，若在未定向的流上使用多字节I/O函数，则将">
<meta name="twitter:image" content="http://o877ej38d.bkt.clouddn.com/apue-5.2.PNG">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
  
<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?bcbfe64f39fa66cb8a2c37046dbb7d1d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">XZH</a></h1>
    <p><a href="/">待出栏码农</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/about">关于</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/06/Unix标准IO库/">
  <time datetime="2016-06-18T01:05:00.000Z">
    2016-06-18
  </time>
</a>
    
    
  
    <h1 class="title">UNIX标准I/O库</h1>
  

  </header>
  
  <div class="entry">
    
      <h2 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h2><p>文件I/O中，当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后续的I/O操作。而对于标准I/O库，它们的操作是围绕流进行的，当使用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。</p>
<p>标准I/O文件流可以用于单字节或多字节（宽）字符集。流的定向决定了所读写的字符是单字节还是多字节的。一个流被创建时是没有定向的，若在未定向的流上使用多字节I/O函数，则将该流的定向设置为宽定向的；若在未定向的流上使用单字节I/O函数，则将该流的定向设置为字节定向的。</p>
<p>有两个函数可以改变流的定向。freopen函数清除一个流的定向，fwide函数设置流的定向。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE *fp, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>根据mode参数值不同:</p>
<ul>
<li>若mode为负，fwide将试图设置该流为字节定向</li>
<li>若mode为正，fwide将试图设置该流为宽定向</li>
<li>若mode为零，fwide仅返回流的当前定向（负为字节定向，正为宽定向，零为未定向）</li>
</ul>
<p>fwide没有返回值表示出错的情况，所以在调用fwide之前，清除errno，返回后检查errno。</p>
<p>FILE是一个结构，包含了标准I/O库为管理流需要的所有信息，包括用于实际I/O的文件描述符、指向用于该缓流冲区的指针、缓冲区的长度、当前在缓冲区中的字节数以及出错标志等。当打开一个流时，标准I/O函数fopen返回一个指向FILE对象的指针。</p>
<h2 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h2><p>对一个进程预定义了3各流，并且它们可以自动地被进程使用，它们是标准输入、标准输出和标准错误，对应的文件描述符为STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO。这三个标准I/O流可以通过预定义的文件指针stdio、stdout和stderr使用。</p>
<h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>标准I/O库提供缓冲的目的是尽可能减少使用read和write调用的次数，对每个I/O流自动地进行缓冲管理。</p>
<p>标准I/O提供3种类型的缓冲：</p>
<ul>
<li><p>全缓冲。在填满标准I/O缓冲区后才进行实际I/O操作。对于驻留在磁盘上的文件通常是由标准I/O库实施全缓冲的。在一个流上第一次进行I/O操作时，相关标准I/O函数通常调用malloc获得需使用的缓冲区。标准I/O的写回操作称为冲洗flush，缓冲区可由标准I/O例程自动冲洗（比如缓冲区满），或者使用fflush冲洗一个流。</p>
</li>
<li><p>行缓冲。当在输入和输出中遇到换行符时，标准I/O库执行I/O操作。当流涉及一个终端时，通常使用行缓冲。行缓冲有两个限制，第一，因为行缓冲的缓冲区长度有限，当缓冲区被填满还没有遇到一个换行符时，也进行I/O操作；第二，如果输入数据来自内核，则冲洗所有行缓冲输出流。</p>
</li>
<li><p>不带缓冲。标准I/O库不对字符进行缓冲存储，即立即进行I/O操作。标准错误流stderr通常是不带缓冲的，这就使得出错信息可以尽快显示出来。</p>
</li>
</ul>
<p>ISO C 要求的缓冲特征：</p>
<ul>
<li>当且仅当标准输入和标准输出并不指向交互式设备时，它们才是全缓冲的。</li>
<li>标准错误绝不会是全缓冲的。</li>
</ul>
<p>大部分系统默认：</p>
<ul>
<li>标准错误是不带缓冲的。</li>
<li>若是指向终端设备的流，则是行缓冲的；否则是全缓冲的。</li>
</ul>
<p>可使用setbuf和setvbuf函数更改缓冲类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setvbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>因为函数的参数是文件指针，所以要修改缓冲类型的流要先被打开。</p>
<p>使用setbuf函数打开或关闭缓冲机制。为了带缓冲进行I/O，参数buf必须指向一个长度为BUFSIZ（<stdio.h>）的缓冲区。通常在此之后该流是全缓冲的，若该流与一个终端设备相关，某些系统也将其设置为行缓冲的。将buf设置为NULL来关闭缓冲。</stdio.h></p>
<p>使用setvbuf可以指定缓冲类型，根据mode不同：</p>
<ul>
<li>_IOFBF 全缓冲</li>
<li>_IOLBF 行缓冲</li>
<li>_IONBF 不带缓冲</li>
</ul>
<p>如果指定一个不带缓冲的流，则忽略buf和size参数。如果指定全缓冲或行缓冲，则buf和size可选择地指定一个缓冲区及其长度。如果该流是带缓冲的，而buf是NULL，则标准I/O库将自动为该流分配适当长度缓冲区，即一个长度为BUFSIZ的缓冲区。</p>
<p>如果在一个函数内分配一个自动变量类的标准I/O缓冲区，则从该函数返回之前，必须关闭该流。</p>
<p>某些实现将缓冲区的一部分用于存放它自己的管理操作信息，所以可存放在缓冲区中的实际数据字节数少于size。</p>
<p>一般而言，应由系统选择缓冲区长度，并自动分配缓冲区，则当关闭该流时，标准I/O库将自动释放缓冲区。</p>
<p>用fflush冲洗一个流。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若参数fp是NULL，则冲洗所有流。</p>
<h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type,</span><br><span class="line">	      FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>fopen函数打开指定路径名的文件</p>
</li>
<li><p>freopen函数在一个指定的流上打开一个指定的文件，若该流已打开，则先关闭该流。若该流已定向，则使用freopen清除该定向。次函数一般用于将一个指定的文件打开为一个预定义的流：标准输入，标准输出或标准错误。</p>
</li>
<li><p>fdopen函数取一个已有的文件描述符，并使一个标准的I/O流与该描述符相结合。次函数常用于创建管道和网络通信通道函数返回的描述符。因为这些特殊类型的文件不能用标准I/O函数fopen打开，所以先调用设备专用函数以获得一个文件描述符，然后用fdopen使一个标准I/O流与该描述符相结合。</p>
</li>
</ul>
<p>type参数值及其意义见下图。</p>
<p><img src="http://o877ej38d.bkt.clouddn.com/apue-5.2.PNG" alt="type参数"></p>
<p>使用字符b作为type一部分，使得标准I/O系统可区分文本文件和二进制文件。因为UNIX内核并不对这两种文件进行区分，所以在UNIX环境下指定字符b作为type的一部分并无作用。</p>

    
    
  </div>
  <footer>
    
      
      
  <div class="tags">
    <a class="tags-link" href="/tags/C/">C</a>, <a class="tags-link" href="/tags/UNIX/">UNIX</a>
  </div>

    
    <div class="clearfix">
      
      <!-- JiaThis Button BEGIN -->
</br>
<div class="jiathis_style">
	<span class="jiathis_txt">分享到：</span>
	<a class="jiathis_button_tools_1"></a>
	<a class="jiathis_button_tools_2"></a>
	<a class="jiathis_button_tools_3"></a>
	<a class="jiathis_button_tools_4"></a>
	<a href="http://www.jiathis.com/share?uid=2102268" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code_mini/jia.js?uid=2102268" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </footer>
</article>



<section id="comment">
  <h1 class="title">评论</h1>
  <div class="ds-thread" data-title="UNIX标准I/O库">
  </div>
</section>

</div>
  </div>
  <footer id="footer"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="site-stat">
<span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次 | </span>
<span id="busuanzi_container_site_uv">
  本站访客数<span id="busuanzi_value_site_uv"></span>人次 | 
</span>
<span id="busuanzi_container_page_pv">
  本页阅读量<span id="busuanzi_value_page_pv"></span>次
</span>
</div>
<div class="copyright">
  
  &copy; 2016 <a href="/">xingzhihao</a>
  
</div>
</footer>
  <script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
  var duoshuoQuery = { short_name: 'xzhspace' };
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';
    ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>


</body>
</html>