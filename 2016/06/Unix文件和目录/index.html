<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>Unix文件和目录 | XZH</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="xingzhihao">
  
  
    <meta name="description" content="文件属性含义，修改文件属性，Unix文件系统结构和符号链接，目录操作。
函数stat、fstat、fstatat和lstat12345#include &amp;lt;sys/stat.h&amp;gt;int stat(const char *restrict pathname, struct stat *restrict buf);int fstat(int fd, struct stat *buf);int">
  
  <meta name="description" content="文件属性含义，修改文件属性，Unix文件系统结构和符号链接，目录操作。
函数stat、fstat、fstatat和lstat12345#include &amp;lt;sys/stat.h&amp;gt;int stat(const char *restrict pathname, struct stat *restrict buf);int fstat(int fd, struct stat *buf);int">
<meta property="og:type" content="article">
<meta property="og:title" content="Unix文件和目录">
<meta property="og:url" content="http://www.xzh.space/2016/06/Unix文件和目录/index.html">
<meta property="og:site_name" content="XZH">
<meta property="og:description" content="文件属性含义，修改文件属性，Unix文件系统结构和符号链接，目录操作。
函数stat、fstat、fstatat和lstat12345#include &amp;lt;sys/stat.h&amp;gt;int stat(const char *restrict pathname, struct stat *restrict buf);int fstat(int fd, struct stat *buf);int">
<meta property="og:image" content="http://o877ej38d.bkt.clouddn.com/apue-4.5.PNG">
<meta property="og:image" content="http://o877ej38d.bkt.clouddn.com/apue-4.6.PNG">
<meta property="og:image" content="http://o877ej38d.bkt.clouddn.com/apue-4.11.PNG">
<meta property="og:image" content="http://o877ej38d.bkt.clouddn.com/apue-4.13.PNG">
<meta property="og:image" content="http://o877ej38d.bkt.clouddn.com/apue-4.14.PNG">
<meta property="og:image" content="http://o877ej38d.bkt.clouddn.com/apue-4.15.PNG">
<meta property="og:updated_time" content="2016-06-06T14:50:06.288Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Unix文件和目录">
<meta name="twitter:description" content="文件属性含义，修改文件属性，Unix文件系统结构和符号链接，目录操作。
函数stat、fstat、fstatat和lstat12345#include &amp;lt;sys/stat.h&amp;gt;int stat(const char *restrict pathname, struct stat *restrict buf);int fstat(int fd, struct stat *buf);int">
<meta name="twitter:image" content="http://o877ej38d.bkt.clouddn.com/apue-4.5.PNG">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
  
<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?bcbfe64f39fa66cb8a2c37046dbb7d1d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">XZH</a></h1>
    <p><a href="/">待出栏码农</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/about">关于</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/06/Unix文件和目录/">
  <time datetime="2016-06-04T16:00:33.000Z">
    2016-06-05
  </time>
</a>
    
    
  
    <h1 class="title">Unix文件和目录</h1>
  

  </header>
  
  <div class="entry">
    
      <p>文件属性含义，修改文件属性，Unix文件系统结构和符号链接，目录操作。</p>
<h2 id="函数stat、fstat、fstatat和lstat"><a href="#函数stat、fstat、fstatat和lstat" class="headerlink" title="函数stat、fstat、fstatat和lstat"></a>函数stat、fstat、fstatat和lstat</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">struct</span> stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> <span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>
<p>stat函数返回指定路径文件有关的信息结构。</p>
<p>fstat函数获得已在fd上打开文件的信息。</p>
<p>lstat函数类似与stat，但当文件是一个符号链接时，lstat返回该符号连接的信息，而不是由该符号链接引用的文件的信息。</p>
<p>fstatat是使用相对与fd的相对位置，这种带at的函数在文件系统中很常见，在说文件I/O时也介绍了open和openat在相对路径上的特点，都类似的，可参照。对于符号链接，fstatat函数返回：</p>
<ul>
<li>符号链接所指向的文件的信息（默认）</li>
<li>符号链接本身的信息（设置了AT_SYMLINK_NOFOLLOW标志）<a id="more"></a>
</li>
</ul>
<p>buf是一个指向结构的指针，上述函数来填充这个结构。</p>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>Unix文件系统总共有6类文件：</p>
<ol>
<li><p>普通文件，Unix内核并不区分文本文件和二进制文件，文件内容的解释是应用程序干的事。</p>
</li>
<li><p>目录文件，包含了其他文件名字以及指向与这些文件有关信息的指针，对一个目录有读权限的任一进程都可以读目录的内容，只有内核可以直接写目录文件，更改目录必须使用目录函数。</p>
</li>
<li><p>块特殊文件，对设备的带缓冲的访问，一次读写固定大小。</p>
</li>
<li><p>字符特殊文件，对设备不带缓冲的访问，每次访问长度可变。系统中的设备要么是字符特殊文件，要么就是块特殊文件。</p>
</li>
<li><p>FIFO，命名管道。</p>
</li>
<li><p>套接字。</p>
</li>
<li><p>符号链接，这种文件指向另一个文件。</p>
</li>
</ol>
<h2 id="设置用户ID和设置组ID"><a href="#设置用户ID和设置组ID" class="headerlink" title="设置用户ID和设置组ID"></a>设置用户ID和设置组ID</h2><p>与一个进程相关联的ID有至少6个。</p>
<p><img src="http://o877ej38d.bkt.clouddn.com/apue-4.5.PNG" alt="进程相关的用户ID和组ID"></p>
<ul>
<li>实际用户ID和实际组ID标识我们是谁，在登陆时取自口令文件中的登陆项，通常在登陆会话期间不变，只有超级用户可以改变它们。</li>
<li>有效用户ID、有效组ID和附属组ID决定了我们的文件访问权限。</li>
<li>保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID的副本。</li>
</ul>
<p>通常有效用户ID等于实际用户ID，有效组ID等于实际组ID。</p>
<p>每个文件有一个所有者和组所有者，分别又stat结构中的st_uid和st_gid指定。</p>
<p>当执行一个程序文件时，进程的有效用户ID通常就是实际用户ID，有效组ID就是实际组ID。但可以在文件模式字st_mode中设置一个特殊标志，其含义是”当执行此文件时，将进程的有效用户ID设置为文件所有者的用户ID（st_uid）”，与此类似，还有另外一个特护送标志位可以对组ID做同样的设置。可知如果文件所有者是超级用户，那编写一个执行此文件的程序就要小心翼翼了。在文件模式中这两位分别称为设置用户ID位和设置组ID位。这两位都在st_mode中，可用S_ISUID和S_USGID测试。</p>
<h2 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h2><p>每个文件有9个访问权限位，可分为三类。</p>
<p><img src="http://o877ej38d.bkt.clouddn.com/apue-4.6.PNG" alt="文件访问权限位"></p>
<p>u、g、o分别表示用户（所有者）、组、其他。</p>
<p>权限规则为：</p>
<ul>
<li>用路径名打开任意类型的文件时，对该路径名中包含的每一个目录，包括它可能隐含的当前工作目录都应具有执行权限。对目录的读权限，只能允许读目录，获得目录中文件名的列表，但不能访问任何一个目录。对目录有执行权限时，才能通过该目录。</li>
<li>读写权限决定了是否可以对文件读或写，在使用open函数时，读权限和O_RDONLY以及O_RDWR相关，写权限和O_WRONLY以及O_RDWR相关。</li>
<li>在open函数中对一个文件指定O_TRUNC标志，必须对该文件具有写权限。</li>
<li>在一个目录中创建新文件，必须对目录具有写权限和执行权限。</li>
<li>删除一个文件，必须要有包含文件的目录的写权限和执行权限，并不需要文件的读写权限。</li>
<li>用exec执行文件，必须对文件具有执行权限，且文件必须是普通文件。</li>
</ul>
<p>内核文件访问权限测试：</p>
<ol>
<li>若进程有效用户ID是0即超级用户，可以访问。</li>
<li>若进程的有效用户ID等于文件所有者ID，且进程为读、写、执行而打开文件时文件的相应用户（所有者）访问权限被设置，可以访问。</li>
<li>若进程的有效组ID或附属组ID之一等于文件的组ID，如果组适当的访问权限被设置，可以访问。</li>
<li>若其他用户相应的访问权限被设置，可以访问。</li>
</ol>
<h2 id="新文件和目录的所有权"><a href="#新文件和目录的所有权" class="headerlink" title="新文件和目录的所有权"></a>新文件和目录的所有权</h2><p>新文件的用户ID设置位进程的有效用户ID。</p>
<p>对于组ID：</p>
<ul>
<li>新文件的组ID可以是进程的有效组ID</li>
<li>新文件的组ID可以是它所在的目录的组ID</li>
</ul>
<h2 id="函数access和faccessat"><a href="#函数access和faccessat" class="headerlink" title="函数access和faccessat"></a>函数access和faccessat</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这两个函数是按实际用户ID和实际组ID来进行访问权限测试的，对于faccessat可以将flag设置为AT_EACCESS来检查有效用户ID和有效组ID。</p>
<p>对于mode：</p>
<ul>
<li>F_OK 测试文件是否存在</li>
<li>R_OK 测试读权限</li>
<li>W_OK 测试写权限</li>
<li>X_OK 测试执行权限</li>
</ul>
<h2 id="函数umask"><a href="#函数umask" class="headerlink" title="函数umask"></a>函数umask</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="keyword">mode_t</span> mask(<span class="keyword">mode_t</span> cmask);</span><br></pre></td></tr></table></figure>
<p>在创建新文件或新目录时，会使用文件模式（mode参数），它指定了新文件或新目录的访问权限，而umask是设置文件模式创建屏蔽字的函数，umask将某一位置为1则在mode中那一位就被屏蔽而成为0，umask可以使用S_IRUSR、S_IWUSR等常量或的结果作参数，一次设置多位。umask的返回值为当前的屏蔽字。</p>
<h2 id="函数chmod、fchmod和fchmodat"><a href="#函数chmod、fchmod和fchmodat" class="headerlink" title="函数chmod、fchmod和fchmodat"></a>函数chmod、fchmod和fchmodat</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>
<p>为改变一个文件的权限位，进程的有效用户ID必须等于文件的所有者ID，或者该进程必须具有超级用户权限。</p>
<p>参数mode的值是下列常量的或。</p>
<p><img src="http://o877ej38d.bkt.clouddn.com/apue-4.11.PNG" alt="chmod的mode常量"></p>
<h2 id="粘着位"><a href="#粘着位" class="headerlink" title="粘着位"></a>粘着位</h2><p>在Unix尚未使用请求分页式技术的早期版本中，S_ISVTX位被称为粘着位，设置了粘着位的文件将在第一次使用被加载以后就一直在交换区中，直到系统重启，这样使得文件被再次使用时有更快的加载速度，因为文件各数据块可能是随机存放的，而交换区是被作为一个连续文件处理的。</p>
<p>现今的系统扩展了粘着位的使用范围，允许对目录设置粘着位，如果一个目录被设置了粘着位，只有对该目录具有写权限的用户且满足下列条件之一，才能删除或重命名该目录下的文件：</p>
<ul>
<li>拥有此文件</li>
<li>拥有此目录</li>
<li>是超级用户</li>
</ul>
<p>一般对/tmp和/var/tmp设置粘着位，任何用户都可以在这两个目录下创建文件，任一用户对这两个目录的权限通常都是读、写和执行，但用户不应能删除或重命名属于其他人的文件。</p>
<h2 id="函数chown、fchown、fchownat和lchown"><a href="#函数chown、fchown、fchownat和lchown" class="headerlink" title="函数chown、fchown、fchownat和lchown"></a>函数chown、fchown、fchownat和lchown</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">git_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uid_t</span> owner, <span class="keyword">git_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, </span><br><span class="line">             <span class="keyword">git_t</span> group, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">git_t</span> group)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在符号链接情况下，lchown和fchownat（设置了AT_SYMLINK_NOFOLLOW标志）更改符号链接本身的所有者，而不是符号链接所指向的文件的所有者。</p>
<p>fchown改变fd参数所指向的打开文件的所有者，既然它在一个已打开的文件上操作，就不能用于改变符号链接的所有者。</p>
<p>fchownat函数在因为at导致的不同以及flag的AT_SYMLINK_NOFOLLOW是否设置上，可以分别和chown以及lchown效果相同。</p>
<p>当_POSIX_CHOWN_RESTRICTED有效时，除了超级用户，不能更改其他用户文件的用户ID。你可以更改你所拥有的文件的组ID，但只能改到你所属的组。</p>
<p>如果这些函数由非超级用户进程调用，则在成功返回时，该文件的设置用户ID位和设置组ID位都被清除。</p>
<h2 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h2><p>stat结构的st_size成员表示以字节位单位的文件的长度，只对普通文件、目录文件和符号链接有效。</p>
<ul>
<li>普通文件，从文件开始，一直到文件结束符EOF的长度</li>
<li>目录文件，长度通常是一个常数的整数倍</li>
<li>符号链接，长度是文件名（即全路径名）的实际字节数，如路径名usr/lib长度为7</li>
</ul>
<p>对于块特殊文件，st_blksize和st_blocks分别表示块大小和块数量。</p>
<p>文件空洞是设置的偏移量超过文件尾端并进行写造成的，含有空洞的文件，可以发现其标示长度大小总是大于其占用的实际磁盘空间，因为空洞并不占实际空间。对该文件进行打印，空洞部分会以0x00输出。但是如果对其进行复制操作，新文件的空洞就占用了空间。</p>
<h2 id="文件截断"><a href="#文件截断" class="headerlink" title="文件截断"></a>文件截断</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>若文件长度大于length，则截断后，length以后的部分将不能访问</li>
<li>若文件长度小于length，则会在不到length的部分创建一个空洞</li>
</ul>
<p>在打开文件时设置O_TRUNC也会将文件截断为0。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>一个磁盘可能有一个或多个分区，每个分区可以包含一个文件系统，i节点是固定程度的记录项，包含有关文件的大部分信息。</p>
<p><img src="http://o877ej38d.bkt.clouddn.com/apue-4.13.PNG" alt="磁盘、分区和文件系统"></p>
<p>那么来详细看目录、文件、i节点以及数据块之间的关系。</p>
<p><img src="http://o877ej38d.bkt.clouddn.com/apue-4.14.PNG" alt="i节点和数据块"></p>
<ul>
<li><p>图中有两个目录项指向同一个i节点，每个i节点都有一个链接计数，表示指向该i节点的目录项数，只有链接计数减少到0时，才可删除该文件，即释放该文件占用的数据块。所以，解除对一个文件的链接，并不总意味着释放该文件占用的数据块。故删除一个目录项的函数被称为unlink而不是delete。stat结构中，st_nlink表示链接计数，基本系统数据类型为nlink_t，常量LINK_MAX制定了一个文件链接数的最大值。这种链接是硬链接。</p>
</li>
<li><p>符号链接文件的实际内容是所指向文件的名字（全路径名），用ls -al观察时，符号链接最前面是l开头的。符号链接的i节点中的文件类型是S_IFLNK。</p>
</li>
<li><p>i节点包含了文件有关的所有信息，文件类型、文件访问权限位、文件长度和指向文件数据块的指针等，stat结构的大部分取自i节点，只有文件名和i节点编号是在目录项中的。i节点编号的数据类型为ino_t。</p>
</li>
<li><p>因为目录项中的i节点编号指向同一文件系统中相应i节点，不能指向另一个文件系统的i节点，所以ln命令（使用link函数）不能跨文件系统。</p>
</li>
<li><p>当在同一文件系统内进行文件重命名，该文件的实际内容并未移动，只需构造一个指向现有i节点的新目录项，并删除老的目录项，链接计数不会改变。这是mv命令的操作方式。</p>
</li>
</ul>
<p>接着看目录的链接计数</p>
<p><img src="http://o877ej38d.bkt.clouddn.com/apue-4.15.PNG" alt="目录的i节点和链接计数"></p>
<p>图中testdir是新创建的目录，任何一个叶目录的链接计数总是2，来自testdir本身以及内部的.项，途中编号2549的i节点是testdir的。另外一个目录对应1267号i节点，它是testdir的父目录，其链接计数大于等于3，来自其本身，其内部的.项，testdir的..项，以及其他的子目录（testdir同一级）的..项。</p>
<h2 id="函数link、linkat、unlink、unlinkat和remove"><a href="#函数link、linkat、unlink、unlinkat和remove" class="headerlink" title="函数link、linkat、unlink、unlinkat和remove"></a>函数link、linkat、unlink、unlinkat和remove</h2><p>创建一个指向现有文件的链接的方法是使用link函数或linkat函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">int</span> nfd, </span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">char</span> *nwepath, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>
<p>existingpath应是已存在的路径名，newpath中的各通过路径应已存在，newpath中最后一个分量（即新的链接名）应尚不存在。</p>
<p>当现有文件是一个符号链接时，flag参数来控制模式：</p>
<ul>
<li>flag设置了AT_SYMLINK_FOLLOW，创建指向符号链接目标的链接</li>
<li>flag清除了AT_SYMLINK_FOLLOW，创建指向符号链接本身的链接</li>
</ul>
<p>创建新目录项和增加链接计数是一个原子操作。</p>
<p>如果支持创建指向一个目录的硬链接，那么也仅有超级用户可以这么做，因为可能在文件系统中造成循环，大多数文件系统的程序都不能处理这种情况，所以，一般不允许对于目录的硬链接。</p>
<p>删除一个现有的目录项，使用unlink函数或unlinkat函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>
<p>删除目录项，并将由pathname引用文件的链接计数减1.如果对该文件还有其他链接，则认可通过其他链接访问该文件的数据。若函数出错，则不进行任何更改。</p>
<p>为了解除对文件的链接，必须对包含该目录项的目录具有写权限和执行权限，如果目录设置了粘着位，除了写权限外，还要满足3个条件，见粘着位相关。</p>
<p>只有链接计数为0时才删除文件的内容，若此时还有进程打开该文件，也不能删除。</p>
<p>关闭文件时，内核进行下述检查，来看是否删除该文件：</p>
<ol>
<li>打开该文件的进程个数是否为0</li>
<li>文件的链接计数是否为0</li>
</ol>
<p>当flag设置了AT_REMOVEDIR标志时，unlinkat可以像rmdir一样删除目录，否则和unlink相同。</p>
<p>unlink必须等文件计数和进程计数都为0才删除文件的特性，经常被用来确保即使是在程序崩溃时，它所创建的临时文件也不会遗留下来。进程用open或creat创建一个文件，然后立即调用unlink，进程依然打开该文件时，它不会被删除，当进程关闭该文件或进程退出时，文件被删除。</p>
<p>如果pathname是符号链接，那么unlink删除该符号链接，而不是删除符号链接的目标文件，给出符号链接名的情况下，没有一个函数能删除该链接所引用的文件。</p>
<p>也可以使用remove函数解除对一个文件或目录的链接，对于文件，remove和unlink相同，对于目录，remove和rmdir相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>

    
    
  </div>
  <footer>
    
      
      
  <div class="tags">
    <a class="tags-link" href="/tags/c/">c</a>, <a class="tags-link" href="/tags/unix/">unix</a>
  </div>

    
    <div class="clearfix">
      
      <!-- JiaThis Button BEGIN -->
</br>
<div class="jiathis_style">
	<span class="jiathis_txt">分享到：</span>
	<a class="jiathis_button_tools_1"></a>
	<a class="jiathis_button_tools_2"></a>
	<a class="jiathis_button_tools_3"></a>
	<a class="jiathis_button_tools_4"></a>
	<a href="http://www.jiathis.com/share?uid=2102268" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code_mini/jia.js?uid=2102268" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </footer>
</article>



<section id="comment">
  <h1 class="title">评论</h1>
  <div class="ds-thread" data-title="Unix文件和目录">
  </div>
</section>

</div>
  </div>
  <footer id="footer"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="site-stat">
<span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次 | </span>
<span id="busuanzi_container_site_uv">
  本站访客数<span id="busuanzi_value_site_uv"></span>人次 | 
</span>
<span id="busuanzi_container_page_pv">
  本页阅读量<span id="busuanzi_value_page_pv"></span>次
</span>
</div>
<div class="copyright">
  
  &copy; 2016 <a href="/">xingzhihao</a>
  
</div>
</footer>
  <script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
  var duoshuoQuery = { short_name: 'xzhspace' };
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';
    ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>


</body>
</html>