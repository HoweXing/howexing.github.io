---
title: UNIX文件和目录
date: 2016-06-05 00:00:33
tags:
  - C
  - UNIX
---
文件属性含义，修改文件属性，UNIX文件系统结构和符号链接，目录操作。

## 函数stat、fstat、fstatat和lstat

```cpp
#include <sys/stat.h>
int stat(const char *restrict pathname, struct stat *restrict buf);
int fstat(int fd, struct stat *buf);
int lstat(const char *restrict pathname, struct stat *restrict buf);
int fstatat(int fd, const char restrict pathname, struct stat *restrict buf, int flag);
```

stat函数返回指定路径文件有关的信息结构。

fstat函数获得已在fd上打开文件的信息。

lstat函数类似与stat，但当文件是一个符号链接时，lstat返回该符号连接的信息，而不是由该符号链接引用的文件的信息。

fstatat是使用相对与fd的相对位置，这种带at的函数在文件系统中很常见，在说文件I/O时也介绍了open和openat在相对路径上的特点，都类似的，可参照。对于符号链接，fstatat函数返回：

* 符号链接所指向的文件的信息（默认）
* 符号链接本身的信息（设置了AT\_SYMLINK\_NOFOLLOW标志）
<!--more-->

buf是一个指向结构的指针，上述函数来填充这个结构。

## 文件类型

UNIX文件系统总共有6类文件：

1. 普通文件，UNIX内核并不区分文本文件和二进制文件，文件内容的解释是应用程序干的事。

2. 目录文件，包含了其他文件名字以及指向与这些文件有关信息的指针，对一个目录有读权限的任一进程都可以读目录的内容，只有内核可以直接写目录文件，更改目录必须使用目录函数。

3. 块特殊文件，对设备的带缓冲的访问，一次读写固定大小。

4. 字符特殊文件，对设备不带缓冲的访问，每次访问长度可变。系统中的设备要么是字符特殊文件，要么就是块特殊文件。

5. FIFO，命名管道。

6. 套接字。

7. 符号链接，这种文件指向另一个文件。

## 设置用户ID和设置组ID

与一个进程相关联的ID有至少6个。

![进程相关的用户ID和组ID](http://o877ej38d.bkt.clouddn.com/apue-4.5.PNG)

* 实际用户ID和实际组ID标识我们是谁，在登陆时取自口令文件中的登陆项，通常在登陆会话期间不变，只有超级用户可以改变它们。
* 有效用户ID、有效组ID和附属组ID决定了我们的文件访问权限。
* 保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID的副本。

通常有效用户ID等于实际用户ID，有效组ID等于实际组ID。

每个文件有一个所有者和组所有者，分别又stat结构中的st\_uid和st\_gid指定。

当执行一个程序文件时，进程的有效用户ID通常就是实际用户ID，有效组ID就是实际组ID。但可以在文件模式字st\_mode中设置一个特殊标志，其含义是"当执行此文件时，将进程的有效用户ID设置为文件所有者的用户ID（st\_uid）"，与此类似，还有另外一个特护送标志位可以对组ID做同样的设置。可知如果文件所有者是超级用户，那编写一个执行此文件的程序就要小心翼翼了。在文件模式中这两位分别称为设置用户ID位和设置组ID位。这两位都在st\_mode中，可用S\_ISUID和S\_USGID测试。

## 文件访问权限

每个文件有9个访问权限位，可分为三类。

![文件访问权限位](http://o877ej38d.bkt.clouddn.com/apue-4.6.PNG)

u、g、o分别表示用户（所有者）、组、其他。

权限规则为：

* 用路径名打开任意类型的文件时，对该路径名中包含的每一个目录，包括它可能隐含的当前工作目录都应具有执行权限。对目录的读权限，只能允许读目录，获得目录中文件名的列表，但不能访问任何一个目录。对目录有执行权限时，才能通过该目录。
* 读写权限决定了是否可以对文件读或写，在使用open函数时，读权限和O\_RDONLY以及O\_RDWR相关，写权限和O\_WRONLY以及O\_RDWR相关。
* 在open函数中对一个文件指定O\_TRUNC标志，必须对该文件具有写权限。
* 在一个目录中创建新文件，必须对目录具有写权限和执行权限。
* 删除一个文件，必须要有包含文件的目录的写权限和执行权限，并不需要文件的读写权限。
* 用exec执行文件，必须对文件具有执行权限，且文件必须是普通文件。

内核文件访问权限测试：

1. 若进程有效用户ID是0即超级用户，可以访问。
2. 若进程的有效用户ID等于文件所有者ID，且进程为读、写、执行而打开文件时文件的相应用户（所有者）访问权限被设置，可以访问。
3. 若进程的有效组ID或附属组ID之一等于文件的组ID，如果组适当的访问权限被设置，可以访问。
4. 若其他用户相应的访问权限被设置，可以访问。

## 新文件和目录的所有权

新文件的用户ID设置位进程的有效用户ID。

对于组ID：
* 新文件的组ID可以是进程的有效组ID
* 新文件的组ID可以是它所在的目录的组ID

## 函数access和faccessat

```cpp
#include <unistd>
int access(const char *pathname, int mode);
int faccessat(int fd, const char *pathname, int mode, int flag);
```

这两个函数是按实际用户ID和实际组ID来进行访问权限测试的，对于faccessat可以将flag设置为AT\_EACCESS来检查有效用户ID和有效组ID。

对于mode：

* F\_OK 测试文件是否存在
* R\_OK 测试读权限
* W\_OK 测试写权限
* X\_OK 测试执行权限

## 函数umask

```cpp
#include <sys/stat.h>
mode_t mask(mode_t cmask);
```

在创建新文件或新目录时，会使用文件模式（mode参数），它指定了新文件或新目录的访问权限，而umask是设置文件模式创建屏蔽字的函数，umask将某一位置为1则在mode中那一位就被屏蔽而成为0，umask可以使用S\_IRUSR、S\_IWUSR等常量或的结果作参数，一次设置多位。umask的返回值为当前的屏蔽字。

## 函数chmod、fchmod和fchmodat

```cpp
#include <sys/stat.h>
int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);
int fchmodat(int fd, const char *pathname, mode_t mode, int flag);
```

为改变一个文件的权限位，进程的有效用户ID必须等于文件的所有者ID，或者该进程必须具有超级用户权限。

参数mode的值是下列常量的或。

![chmod的mode常量](http://o877ej38d.bkt.clouddn.com/apue-4.11.PNG)

## 粘着位

在UNIX尚未使用请求分页式技术的早期版本中，S\_ISVTX位被称为粘着位，设置了粘着位的文件将在第一次使用被加载以后就一直在交换区中，直到系统重启，这样使得文件被再次使用时有更快的加载速度，因为文件各数据块可能是随机存放的，而交换区是被作为一个连续文件处理的。

现今的系统扩展了粘着位的使用范围，允许对目录设置粘着位，如果一个目录被设置了粘着位，只有对该目录具有写权限的用户且满足下列条件之一，才能删除或重命名该目录下的文件：

* 拥有此文件
* 拥有此目录
* 是超级用户

一般对/tmp和/var/tmp设置粘着位，任何用户都可以在这两个目录下创建文件，任一用户对这两个目录的权限通常都是读、写和执行，但用户不应能删除或重命名属于其他人的文件。

## 函数chown、fchown、fchownat和lchown

```cpp
#include <unistd.h>
int chown(const char *pathname, uid_t owner, git_t group);
int fchown(int fd, uid_t owner, git_t group);
int fchownat(int fd, const char *pathname, uid_t owner, 
             git_t group, int flag);
int lchown(const char *pathname, uid_t owner, git_t group);
```

在符号链接情况下，lchown和fchownat（设置了AT\_SYMLINK\_NOFOLLOW标志）更改符号链接本身的所有者，而不是符号链接所指向的文件的所有者。

fchown改变fd参数所指向的打开文件的所有者，既然它在一个已打开的文件上操作，就不能用于改变符号链接的所有者。

fchownat函数在因为at导致的不同以及flag的AT\_SYMLINK\_NOFOLLOW是否设置上，可以分别和chown以及lchown效果相同。

当\_POSIX\_CHOWN\_RESTRICTED有效时，除了超级用户，不能更改其他用户文件的用户ID。你可以更改你所拥有的文件的组ID，但只能改到你所属的组。

如果这些函数由非超级用户进程调用，则在成功返回时，该文件的设置用户ID位和设置组ID位都被清除。

## 文件长度

stat结构的st\_size成员表示以字节位单位的文件的长度，只对普通文件、目录文件和符号链接有效。

* 普通文件，从文件开始，一直到文件结束符EOF的长度
* 目录文件，长度通常是一个常数的整数倍
* 符号链接，长度是文件名（即全路径名）的实际字节数，如路径名usr/lib长度为7

对于块特殊文件，st\_blksize和st\_blocks分别表示块大小和块数量。

文件空洞是设置的偏移量超过文件尾端并进行写造成的，含有空洞的文件，可以发现其标示长度大小总是大于其占用的实际磁盘空间，因为空洞并不占实际空间。对该文件进行打印，空洞部分会以0x00输出。但是如果对其进行复制操作，新文件的空洞就占用了空间。

## 文件截断

```cpp
#include <unistd.h>
int truncate(const char *pathname, off_t length);
int ftruncate(int fd, off_t length);
```

* 若文件长度大于length，则截断后，length以后的部分将不能访问
* 若文件长度小于length，则会在不到length的部分创建一个空洞

在打开文件时设置O\_TRUNC也会将文件截断为0。

## 文件系统

一个磁盘可能有一个或多个分区，每个分区可以包含一个文件系统，i节点是固定程度的记录项，包含有关文件的大部分信息。

![磁盘、分区和文件系统](http://o877ej38d.bkt.clouddn.com/apue-4.13.PNG)

那么来详细看目录、文件、i节点以及数据块之间的关系。

![i节点和数据块](http://o877ej38d.bkt.clouddn.com/apue-4.14.PNG)

* 图中有两个目录项指向同一个i节点，每个i节点都有一个链接计数，表示指向该i节点的目录项数，只有链接计数减少到0时，才可删除该文件，即释放该文件占用的数据块。所以，解除对一个文件的链接，并不总意味着释放该文件占用的数据块。故删除一个目录项的函数被称为unlink而不是delete。stat结构中，st\_nlink表示链接计数，基本系统数据类型为nlink_t，常量LINK\_MAX制定了一个文件链接数的最大值。这种链接是硬链接。

* 符号链接文件的实际内容是所指向文件的名字（全路径名），用ls -al观察时，符号链接最前面是l开头的。符号链接的i节点中的文件类型是S\_IFLNK。

* i节点包含了文件有关的所有信息，文件类型、文件访问权限位、文件长度和指向文件数据块的指针等，stat结构的大部分取自i节点，只有文件名和i节点编号是在目录项中的。i节点编号的数据类型为ino\_t。

* 因为目录项中的i节点编号指向同一文件系统中相应i节点，不能指向另一个文件系统的i节点，所以ln命令（使用link函数）不能跨文件系统。

* 当在同一文件系统内进行文件重命名，该文件的实际内容并未移动，只需构造一个指向现有i节点的新目录项，并删除老的目录项，链接计数不会改变。这是mv命令的操作方式。

接着看目录的链接计数

![目录的i节点和链接计数](http://o877ej38d.bkt.clouddn.com/apue-4.15.PNG)

图中testdir是新创建的目录，任何一个叶目录的链接计数总是2，来自testdir本身以及内部的.项，途中编号2549的i节点是testdir的。另外一个目录对应1267号i节点，它是testdir的父目录，其链接计数大于等于3，来自其本身，其内部的.项，testdir的..项，以及其他的子目录（testdir同一级）的..项。

## 函数link、linkat、unlink、unlinkat和remove

创建一个指向现有文件的链接的方法是使用link函数或linkat函数。

```cpp
#include <unistd.h>
int link(const char *existingpath, const char *newpath);
int linkat(int efd, const char *existingpath, int nfd, 
           const char *nwepath, int flag);
```

existingpath应是已存在的路径名，newpath中的各通过路径应已存在，newpath中最后一个分量（即新的链接名）应尚不存在。

当现有文件是一个符号链接时，flag参数来控制模式：

* flag设置了AT\_SYMLINK\_FOLLOW，创建指向符号链接目标的链接
* flag清除了AT\_SYMLINK\_FOLLOW，创建指向符号链接本身的链接

创建新目录项和增加链接计数是一个原子操作。

如果支持创建指向一个目录的硬链接，那么也仅有超级用户可以这么做，因为可能在文件系统中造成循环，大多数文件系统的程序都不能处理这种情况，所以，一般不允许对于目录的硬链接。

删除一个现有的目录项，使用unlink函数或unlinkat函数。

```cpp
#include <unistd.h>
int unlink(const char *pathname);
int unlinkat(int fd, const char *path, int flag);
```
删除目录项，并将由pathname引用文件的链接计数减1.如果对该文件还有其他链接，则认可通过其他链接访问该文件的数据。若函数出错，则不进行任何更改。

为了解除对文件的链接，必须对包含该目录项的目录具有写权限和执行权限，如果目录设置了粘着位，除了写权限外，还要满足3个条件，见粘着位相关。

只有链接计数为0时才删除文件的内容，若此时还有进程打开该文件，也不能删除。

关闭文件时，内核进行下述检查，来看是否删除该文件：

1. 打开该文件的进程个数是否为0
2. 文件的链接计数是否为0

当flag设置了AT\_REMOVEDIR标志时，unlinkat可以像rmdir一样删除目录，否则和unlink相同。

unlink必须等文件计数和进程计数都为0才删除文件的特性，经常被用来确保即使是在程序崩溃时，它所创建的临时文件也不会遗留下来。进程用open或creat创建一个文件，然后立即调用unlink，进程依然打开该文件时，它不会被删除，当进程关闭该文件或进程退出时，文件被删除。

如果pathname是符号链接，那么unlink删除该符号链接，而不是删除符号链接的目标文件，给出符号链接名的情况下，没有一个函数能删除该链接所引用的文件。

也可以使用remove函数解除对一个文件或目录的链接，对于文件，remove和unlink相同，对于目录，remove和rmdir相同。

```cpp
#include <stdio.h>
int remove(const char *pathname);
```

## 函数rename和renameat

文件或目录可以用rename函数或者renameat函数进行重命名。

```cpp
#include <stdio.h>
int rename(const char *oldname, const char *newname);
int renameat(int oldfd, const char *oldname, int newfd,
             const char *newname);
```

1. 如果oldname指的是一个文件而不是目录，那么为该文件或符号链接重命名。此时，newname若已存在，则它不能是一个目录，应该也是一个文件，将先删除该已存在的目录项，再将oldname重命名为newname，对包含oldname的目录和包含newname的目录都要有写权限和执行权限（因为修改目录项），因为将更改这两个目录。

2. 如果oldname指的是一个目录，那么为该目录重命名。此时newname若已存在，则它应该也是一个目录，而且应该是空目录，将先把它删除，再将olaname重命名为newname。oldname不应该是oldname的一个路径前缀，因为删除了的oldname的叶目录，又出现在newname之中。

3. 如果oldname或newname引用符号链接，则处理的是符号链接本身，而不是它所引用的文件。

4. 不能对.和..进行重命名。

5. 若oldname和newname相同，不做任何操作。

## 符号链接

符号链接是对一个文件的间接指针，它与上一节所述的硬链接有所不同，硬链接之间指向文件的i节点，引入符号链接的原因是为了避开硬链接的一些限制：

* 硬链接通常要求链接和文件位于同一文件系统
* 只有超级用户才能创建指向目录的硬链接（为了避免循环）

符号链接一般用于将一个文件或整个目录结构移到系统中另一个位置。

当使用以名字引用文件的函数时，要知道该函数是否跟随符号链接，跟随则处理符号链接的目标文件，否则处理符号链接自身。

![函数是否跟随符号链接](http://o877ej38d.bkt.clouddn.com/apue-4.17.PNG)

对于mk和rm开头的函数，路径名是符号链接时会出错返回。

以文件描述符fd作为参数的函数，其fd是open打开的，而open已经跟随了符号链接。

例外，同时用O\_CREAT和\_EXCL两者调用open函数，若路径名为符号链接，open将出错返回，errno设置为EEXIST，这种处理方式意图是堵塞一个安全漏洞，以防止具有特权的进程被诱骗写错误的文件。

使用符号链接可能在文件系统中引入循环，大多数查找路径名的函数在这种情况下都将出错返回，errno为ELOOP。

下图中有一个构成循环的符号链接。

![构成循环的符号链接](http://o877ej38d.bkt.clouddn.com/apue-4.18.PNG)

foo目录下，有一个testdir的符号链接，而这个符号链接指向foo。

这样一个循环是很容易消除的，因为unlink并不跟随符号链接，所以可以unlink文件foo/testdir。但是如果创建了一个构成这种循环的硬链接，就很难消除它，所以link函数只允许超级用户构造指向目录的硬链接。

用open打开文件时，如果参数是一个符号链接，open将跟随符号链接到目标文件，若目标文件不存在，open将出错返回。所以打开一个存在的符号链接，open也可能出错返回，因为链接指向的目标不存在。

## 创建和读取符号链接

用symlink和symlinkat函数创建一个符号链接。

```cpp
#include <unistd.h>
int symlink(const char *actualpath, const char *sympath);
int symlinkat(const char *actualpath, int fd, const char *sympath);
```

函数创建了一个指向actualpath的新目录项sympath，并不要求actualpath一定存在，它们也不需要位于同一文件系统。

因为open函数跟随符号链接，所以提供了readlink和readlinkat函数打开链接本身并读该链接中的名字。

```cpp
#include <unistd.h>
ssize_t readlink(const char *restrict pathname, char *restrict buf,
		 size_t bufsize);
ssize_t readlinkat(int fd, const char *restrict pathname, char *restrict buf,
		   size_t bufsize);
```

## 文件的时间

08年之后的版本，stat结构中时间字段的精度从秒提高到秒加上纳秒。而文件属性保存的时间的实际精度依赖于文件系统的实现，如果系统只能精确到秒，那么纳秒部分被填充0，如果系统精确超过了秒，那么将精确到纳秒。

每个文件有下列三种时间字段：

![三个时间字段](http://o877ej38d.bkt.clouddn.com/apue-4.19.PNG)

修改时间（st\_mtim）和状态更改时间（st\_ctim）之间的区别：

* 修改时间是文件内容最后一次被修改的时间，状态更改时间是该文件的i节点最后一次被修改的时间
* i节点中的所有信息都是与文件的实际内容分开存放的
* 更改文件的访问权限、更改用户ID、更改链接数等都是更改了i节点的内容，并没有改动文件实际内容
* 系统并不维护对一个i节点的最后一次访问时间

目录是包含目录项的文件，增加、删除或修改目录项会影响到它所在目录的三个时间

![函数调用对时间字段的影响](http://o877ej38d.bkt.clouddn.com/apue-4.20.PNG)

## 函数futimens、utimensat和utimes

文件的访问和修改时间可以用以下几个函数更改，futimens和utimensat函数可以指定纳秒精度的时间戳，timespec结构是和stat结构中的时间结构相同。

```cpp
#include <sys/stat.h>
int futimens(int fd, const struct timespec times[2]);
int utimensat(int fd, const char *path, const struct timespec times[2],
	      int flag);
```

time数组第一个元素是访问时间，第二个是修改时间，都是UNIX时间戳秒数，不足秒的用纳秒表示。

时间戳指定方式：

* 若times是空指针，访问时间和修改时间都设为当前时间
* 若一个数组元素的tv\_nsec字段值为UTIME\_NOW，相应的时间戳设为当前时间，忽略相应的tv\_sec字段
* 若一个数组元素的tv\_nsec字段值为UTIME\_OMIT，相应的时间戳保持不变，忽略相应的tv\_sec字段
* 否则时间戳设置为相应的tx\_nsec和tv\_sec字段值

执行这些函数需要的权限，取决于times参数的值：

* 若times是空指针，或者任意tv\_nsec字段为UTIME\_NOW，则进程的有效ID必须等于文件所有者ID，必须具有写权限，或者为超级用户进程
* 若times是非空指针，并且任一tv\_nsec字段值既不是UTIME\_NOW也不是UTIME\_OMIT，则进程的有效用户ID必须等于文件所有者ID，或者进程是超级用户进程，只有写权限不够
* 若times是非空指针，并且两个tv\_nsec字段值都为UTIME\_OMIT，就不执行权限检查

对于符号链接，utimensat默认行为是跟随符号链接，并把文件的时间改成符号链接的时间，通过设置flag为AT\_SYMLINK\_NOFOLLOW，则符号链接本身的时间就会被修改。

```cpp
#include <sys/time.h>
int utimes(const char *pathname, const struct timeval times[2]);
```

除了timeval结构是如下之外，和上面两个函数类似

```cpp
struct timeval{
	time_t tv_sec; //秒
	long tv_usec; //微秒
}
```

## 函数mkdir、mkdirat和rmdir

用mkdir和mkdirat函数创建目录，用rmdir函数删除目录。

```cpp
#include <sys/stat.h>
int mkdir(const char *pathname, mode_t mode);
int mkdirat(int fd, const char *pathname, mode_t mode);
```

创建一个新目录，其中.和..目录项是自动创建的。文件访问权限mode由进程的文件模式创建屏蔽字修改。常见的错误是没有给目录设置执行权限位，这样访问不了目录中的文件名。

```cpp
#include <unistd.h>
int rmdir(const char *pathname);
```

用rmdir函数可以删除一个空目录，即仅包含.和..的目录。

如果调用rmdir函数使目录的链接计数成为0，并且也没有其他进程打开此目录，则释放此目录占用的空间。如果在链接计数达到0时，有一个或多个进程打开此目录，则在此函数返回前删除最后一个链接及.和..项。另外，在此目录中不能在创建新文件。但是在最后一个进程关闭它之前不释放该目录。即使另一些进程打开该目录，它们在此目录下也不能执行其他操作，因为为了使rmdir函数成功执行，该目录必须是空的。

## 读目录

对目录具有访问权限的用户都可以读该目录，但是为了防止文件系统产生混乱，只有内核才能写目录。一个目录的写权限位和执行权限位决定了在该目录中能否创建新文件以及删除文件，它们并不表示能否写目录本身。

```cpp
#include <dirent.h>
DIR *opendir(const char *pathname);
DIR *fdopendir(int fd);
struct dirent *readdir(DIR *dp);
void rewinddir(DIR *dp);
int closedir(DIR *dp);
long telldir(DIR *dp);
void seekdir(DIR *dp, long loc);
```

opendir和fdopendir分别将路径名和文件描述符转换成目录处理函数需要的DIR结构。

readdir以此读取目录流信息。若DIR结构由opendir获得，opendir自动进行了初始化操作，使第一个readdir但会目录中的第一个目录项，若DIR由fdopendir获得，readdir返回的第一项取决于传给fdopendir函数的文件描述符相关联的文件偏移量。目录中各目录项的顺序与实现有关，它们通常并不按字母顺序排列。

rewinddir将目录流当前读位置转移到开头。closedir关闭目录流。

telldie记录一个目录流的当前位置，一个偏移量。seekdir将当前读取位置切换到指定位置。

## 函数chdir、fchdir和getcwd

每个进程都有个当前工作目录，是搜索所有相对路径名的起点。进程调用chdir或fchdir可以更改该进程的当前工作目录。chdir跟随符号链接。

```cpp
#include <unistd.h>
int chdir(const char *pathname);
int fchdir(int fd);
```

getcwd函数可以从.开始循..找到上级目录，一直到根，这样就获得了当前工作目录的完整路径名。

```cpp
#include <unistd.h>
char *getcwd(char *buf, size_t size);
```

参数是缓冲区地址buf和其长度size。buf要足够大容纳路径名和结束符，否则出错，返回NULL。

## 设备特殊文件

* 每个文件系统所在的存储设备都由其主、次设备号表示。设备号所用的数据类型是基本系统数据类型dev\_t。主设备号标识设备驱动程序，次设备号标识特定的子设备。一个磁盘驱动器经常包含若干个文件系统。在同一磁盘驱动器上的各文件系统通常具有相同的主设备号，但次设备号却不同。
* 通常可以使用两个宏major和minor来访问主次设备号。
* 系统中与每个文件名关联的st\_dev值是文件系统的设备号，该文件系统包含了这一文件名以及与其对应的i节点。
* 只有字符特殊文件和块特殊文件才有st\_rdev值。此值包含实际设备的设备号。

## 文件访问权限位小结

![文件访问权限位小结](http://o877ej38d.bkt.clouddn.com/apue-4.26.PNG)
