---
title: Unix文件和目录
date: 2016-06-05 00:00:33
tags:
  - unix
  - c
---
文件属性含义，修改文件属性，Unix文件系统结构和符号链接，目录操作。

## 函数stat、fstat、fstatat和lstat

```cpp
#include <sys/stat.h>
int stat(const char *restrict pathname, struct stat *restrict buf);
int fstat(int fd, struct stat *buf);
int lstat(const char *restrict pathname, struct stat *restrict buf);
int fstatat(int fd, const char restrict pathname, struct stat *restrict buf, int flag);
```

stat函数返回指定路径文件有关的信息结构。

fstat函数获得已在fd上打开文件的信息。

lstat函数类似与stat，但当文件是一个符号链接时，lstat返回该符号连接的信息，而不是由该符号链接引用的文件的信息。

fstatat是使用相对与fd的相对位置，这种带at的函数在文件系统中很常见，在说文件I/O时也介绍了open和openat在相对路径上的特点，都类似的，可参照。对于符号链接，fstatat函数返回：

* 符号链接所指向的文件的信息（默认）
* 符号链接本身的信息（设置了AT\_SYMLINK\_NOFOLLOW标志）
<!--more-->

buf是一个指向结构的指针，上述函数来填充这个结构。

## 文件类型

Unix文件系统总共有6类文件：

1. 普通文件，Unix内核并不区分文本文件和二进制文件，文件内容的解释是应用程序干的事。

2. 目录文件，包含了其他文件名字以及指向与这些文件有关信息的指针，对一个目录有读权限的任一进程都可以读目录的内容，只有内核可以直接写目录文件，更改目录必须使用目录函数。

3. 块特殊文件，对设备的带缓冲的访问，一次读写固定大小。

4. 字符特殊文件，对设备不带缓冲的访问，每次访问长度可变。系统中的设备要么是字符特殊文件，要么就是块特殊文件。

5. FIFO，命名管道。

6. 套接字。

7. 符号链接，这种文件指向另一个文件。

## 设置用户ID和设置组ID

与一个进程相关联的ID有至少6个。

![进程相关的用户ID和组ID](http://o877ej38d.bkt.clouddn.com/apue-4.5.PNG)

* 实际用户ID和实际组ID标识我们是谁，在登陆时取自口令文件中的登陆项，通常在登陆会话期间不变，只有超级用户可以改变它们。
* 有效用户ID、有效组ID和附属组ID决定了我们的文件访问权限。
* 保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID的副本。

通常有效用户ID等于实际用户ID，有效组ID等于实际组ID。

每个文件有一个所有者和组所有者，分别又stat结构中的st\_uid和st\_gid指定。

当执行一个程序文件时，进程的有效用户ID通常就是实际用户ID，有效组ID就是实际组ID。但可以在文件模式字st\_mode中设置一个特殊标志，其含义是"当执行此文件时，将进程的有效用户ID设置为文件所有者的用户ID（st\_uid）"，与此类似，还有另外一个特护送标志位可以对组ID做同样的设置。可知如果文件所有者是超级用户，那编写一个执行此文件的程序就要小心翼翼了。在文件模式中这两位分别称为设置用户ID位和设置组ID位。这两位都在st\_mode中，可用S\_ISUID和S\_USGID测试。

## 文件访问权限

每个文件有9个访问权限位，可分为三类。

![文件访问权限位](http://o877ej38d.bkt.clouddn.com/apue-4.6.PNG)

u、g、o分别表示用户（所有者）、组、其他。

权限规则为：

* 用路径名打开任意类型的文件时，对该路径名中包含的每一个目录，包括它可能隐含的当前工作目录都应具有执行权限。对目录的读权限，只能允许读目录，获得目录中文件名的列表，但不能访问任何一个目录。对目录有执行权限时，才能通过该目录。
* 读写权限决定了是否可以对文件读或写，在使用open函数时，读权限和O\_RDONLY以及O\_RDWR相关，写权限和O\_WRONLY以及O\_RDWR相关。
* 在open函数中对一个文件指定O\_TRUNC标志，必须对该文件具有写权限。
* 在一个目录中创建新文件，必须对目录具有写权限和执行权限。
* 删除一个文件，必须要有包含文件的目录的写权限和执行权限，并不需要文件的读写权限。
* 用exec执行文件，必须对文件具有执行权限，且文件必须是普通文件。

内核文件访问权限测试：

1. 若进程有效用户ID是0即超级用户，可以访问。
2. 若进程的有效用户ID等于文件所有者ID，且进程为读、写、执行而打开文件时文件的相应用户（所有者）访问权限被设置，可以访问。
3. 若进程的有效组ID或附属组ID之一等于文件的组ID，如果组适当的访问权限被设置，可以访问。
4. 若其他用户相应的访问权限被设置，可以访问。

## 新文件和目录的所有权

新文件的用户ID设置位进程的有效用户ID。

对于组ID：
* 新文件的组ID可以是进程的有效组ID
* 新文件的组ID可以是它所在的目录的组ID

## 函数access和faccessat

```cpp
#include <unistd>
int access(const char *pathname, int mode);
int faccessat(int fd, const char *pathname, int mode, int flag);
```

这两个函数是按实际用户ID和实际组ID来进行访问权限测试的，对于faccessat可以将flag设置为AT\_EACCESS来检查有效用户ID和有效组ID。

对于mode：

* F\_OK 测试文件是否存在
* R\_OK 测试读权限
* W\_OK 测试写权限
* X\_OK 测试执行权限

## 函数umask

```cpp
#include <sys/stat.h>
mode_t mask(mode_t cmask);
```

在创建新文件或新目录时，会使用文件模式（mode参数），它指定了新文件或新目录的访问权限，而umask是设置文件模式创建屏蔽字的函数，umask将某一位置为1则在mode中那一位就被屏蔽而成为0，umask可以使用S\_IRUSR、S\_IWUSR等常量或的结果作参数，一次设置多位。umask的返回值为当前的屏蔽字。

## 函数chmod、fchmod和fchmodat

```cpp
#include <sys/stat.h>
int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);
int fchmodat(int fd, const char *pathname, mode_t mode, int flag);
```

为改变一个文件的权限位，进程的有效用户ID必须等于文件的所有者ID，或者该进程必须具有超级用户权限。

参数mode的值是下列常量的或。

![chmod的mode常量](http://o877ej38d.bkt.clouddn.com/apue-4.11.PNG)

## 粘着位

在Unix尚未使用请求分页式技术的早期版本中，S\_ISVTX位被称为粘着位，设置了粘着位的文件将在第一次使用被加载以后就一直在交换区中，直到系统重启，这样使得文件被再次使用时有更快的加载速度，因为文件各数据块可能是随机存放的，而交换区是被作为一个连续文件处理的。

现今的系统扩展了粘着位的使用范围，允许对目录设置粘着位，如果一个目录被设置了粘着位，只有对该目录具有写权限的用户且满足下列条件之一，才能删除或重命名该目录下的文件：

* 拥有此文件
* 拥有此目录
* 是超级用户

一般对/tmp和/var/tmp设置粘着位，任何用户都可以在这两个目录下创建文件，任一用户对这两个目录的权限通常都是读、写和执行，但用户不应能删除或重命名属于其他人的文件。

## 函数chown、fchown、fchownat和lchown

```cpp
#include <unistd.h>
int chown(const char *pathname, uid_t owner, git_t group);
int fchown(int fd, uid_t owner, git_t group);
int fchownat(int fd, const char *pathname, uid_t owner, 
             git_t group, int flag);
int lchown(const char *pathname, uid_t owner, git_t group);
```

在符号链接情况下，lchown和fchownat（设置了AT\_SYMLINK\_NOFOLLOW标志）更改符号链接本身的所有者，而不是符号链接所指向的文件的所有者。

fchown改变fd参数所指向的打开文件的所有者，既然它在一个已打开的文件上操作，就不能用于改变符号链接的所有者。

fchownat函数在因为at导致的不同以及flag的AT\_SYMLINK\_NOFOLLOW是否设置上，可以分别和chown以及lchown效果相同。

当\_POSIX\_CHOWN\_RESTRICTED有效时，除了超级用户，不能更改其他用户文件的用户ID。你可以更改你所拥有的文件的组ID，但只能改到你所属的组。

如果这些函数由非超级用户进程调用，则在成功返回时，该文件的设置用户ID位和设置组ID位都被清除。
