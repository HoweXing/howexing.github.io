---
title: UNIX标准I/O库
date: 2016-06-18 09:05:00
tags:
  - C
  - UNIX
---
## 流和FILE对象

文件I/O中，当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后续的I/O操作。而对于标准I/O库，它们的操作是围绕流进行的，当使用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。

标准I/O文件流可以用于单字节或多字节（宽）字符集。流的定向决定了所读写的字符是单字节还是多字节的。一个流被创建时是没有定向的，若在未定向的流上使用多字节I/O函数，则将该流的定向设置为宽定向的；若在未定向的流上使用单字节I/O函数，则将该流的定向设置为字节定向的。

有两个函数可以改变流的定向。freopen函数清除一个流的定向，fwide函数设置流的定向。

```cpp
#include <stdio.h>
#include <wchar.h>
int fwide(FILE *fp, int mode);
```
<!--more-->
根据mode参数值不同:

* 若mode为负，fwide将试图设置该流为字节定向
* 若mode为正，fwide将试图设置该流为宽定向
* 若mode为零，fwide仅返回流的当前定向（负为字节定向，正为宽定向，零为未定向）

fwide没有返回值表示出错的情况，所以在调用fwide之前，清除errno，返回后检查errno。

FILE是一个结构，包含了标准I/O库为管理流需要的所有信息，包括用于实际I/O的文件描述符、指向用于该缓流冲区的指针、缓冲区的长度、当前在缓冲区中的字节数以及出错标志等。当打开一个流时，标准I/O函数fopen返回一个指向FILE对象的指针。

## 标准输入、标准输出和标准错误

对一个进程预定义了3各流，并且它们可以自动地被进程使用，它们是标准输入、标准输出和标准错误，对应的文件描述符为STDIN\_FILENO、STDOUT\_FILENO、STDERR\_FILENO。这三个标准I/O流可以通过预定义的文件指针stdio、stdout和stderr使用。

## 缓冲

标准I/O库提供缓冲的目的是尽可能减少使用read和write调用的次数，对每个I/O流自动地进行缓冲管理。

标准I/O提供3种类型的缓冲：

* 全缓冲。在填满标准I/O缓冲区后才进行实际I/O操作。对于驻留在磁盘上的文件通常是由标准I/O库实施全缓冲的。在一个流上第一次进行I/O操作时，相关标准I/O函数通常调用malloc获得需使用的缓冲区。标准I/O的写回操作称为冲洗flush，缓冲区可由标准I/O例程自动冲洗（比如缓冲区满），或者使用fflush冲洗一个流。

* 行缓冲。当在输入和输出中遇到换行符时，标准I/O库执行I/O操作。当流涉及一个终端时，通常使用行缓冲。行缓冲有两个限制，第一，因为行缓冲的缓冲区长度有限，当缓冲区被填满还没有遇到一个换行符时，也进行I/O操作；第二，如果输入数据来自内核，则冲洗所有行缓冲输出流。

* 不带缓冲。标准I/O库不对字符进行缓冲存储，即立即进行I/O操作。标准错误流stderr通常是不带缓冲的，这就使得出错信息可以尽快显示出来。

ISO C 要求的缓冲特征：

* 当且仅当标准输入和标准输出并不指向交互式设备时，它们才是全缓冲的。
* 标准错误绝不会是全缓冲的。

大部分系统默认：

* 标准错误是不带缓冲的。
* 若是指向终端设备的流，则是行缓冲的；否则是全缓冲的。

可使用setbuf和setvbuf函数更改缓冲类型。

```cpp
#include<stdio.h>
void setbuf(FILE *restrict fp, char *restrict buf);
void setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);
```

因为函数的参数是文件指针，所以要修改缓冲类型的流要先被打开。

使用setbuf函数打开或关闭缓冲机制。为了带缓冲进行I/O，参数buf必须指向一个长度为BUFSIZ（<stdio.h>）的缓冲区。通常在此之后该流是全缓冲的，若该流与一个终端设备相关，某些系统也将其设置为行缓冲的。将buf设置为NULL来关闭缓冲。

使用setvbuf可以指定缓冲类型，根据mode不同：

* \_IOFBF 全缓冲
* \_IOLBF 行缓冲
* \_IONBF 不带缓冲

如果指定一个不带缓冲的流，则忽略buf和size参数。如果指定全缓冲或行缓冲，则buf和size可选择地指定一个缓冲区及其长度。如果该流是带缓冲的，而buf是NULL，则标准I/O库将自动为该流分配适当长度缓冲区，即一个长度为BUFSIZ的缓冲区。

如果在一个函数内分配一个自动变量类的标准I/O缓冲区，则从该函数返回之前，必须关闭该流。

某些实现将缓冲区的一部分用于存放它自己的管理操作信息，所以可存放在缓冲区中的实际数据字节数少于size。

一般而言，应由系统选择缓冲区长度，并自动分配缓冲区，则当关闭该流时，标准I/O库将自动释放缓冲区。

用fflush冲洗一个流。

```cpp
#include <stdio.h>
int fflush(FILE *fp);
```

若参数fp是NULL，则冲洗所有流。

## 打开流

```cpp
#include <stdio.h>
FILE *fopen(const char *restrict pathname, const char *restrict type);
FILE *freopen(const char *restrict pathname, const char *restrict type,
	      FILE *restrict fp);
FILE *fdopen(int fd, const char *type);
```

* fopen函数打开指定路径名的文件

* freopen函数在一个指定的流上打开一个指定的文件，若该流已打开，则先关闭该流。若该流已定向，则使用freopen清除该定向。次函数一般用于将一个指定的文件打开为一个预定义的流：标准输入，标准输出或标准错误。

* fdopen函数取一个已有的文件描述符，并使一个标准的I/O流与该描述符相结合。次函数常用于创建管道和网络通信通道函数返回的描述符。因为这些特殊类型的文件不能用标准I/O函数fopen打开，所以先调用设备专用函数以获得一个文件描述符，然后用fdopen使一个标准I/O流与该描述符相结合。

type参数值及其意义见下图。

![type参数](http://o877ej38d.bkt.clouddn.com/apue-5.2.PNG)

使用字符b作为type一部分，使得标准I/O系统可区分文本文件和二进制文件。因为UNIX内核并不对这两种文件进行区分，所以在UNIX环境下指定字符b作为type的一部分并无作用。
