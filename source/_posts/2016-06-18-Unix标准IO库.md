---
title: UNIX标准I/O库
date: 2016-06-18 09:05:00
tags:
  - C
  - UNIX
---
## 流和FILE对象

文件I/O中，当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后续的I/O操作。而对于标准I/O库，它们的操作是围绕流进行的，当使用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。

标准I/O文件流可以用于单字节或多字节（宽）字符集。流的定向决定了所读写的字符是单字节还是多字节的。一个流被创建时是没有定向的，若在未定向的流上使用多字节I/O函数，则将该流的定向设置为宽定向的；若在未定向的流上使用单字节I/O函数，则将该流的定向设置为字节定向的。

有两个函数可以改变流的定向。freopen函数清除一个流的定向，fwide函数设置流的定向。

```cpp
#include <stdio.h>
#include <wchar.h>
int fwide(FILE *fp, int mode);
```
<!--more-->
根据mode参数值不同:

* 若mode为负，fwide将试图设置该流为字节定向
* 若mode为正，fwide将试图设置该流为宽定向
* 若mode为零，fwide仅返回流的当前定向（负为字节定向，正为宽定向，零为未定向）

fwide没有返回值表示出错的情况，所以在调用fwide之前，清除errno，返回后检查errno。

FILE是一个结构，包含了标准I/O库为管理流需要的所有信息，包括用于实际I/O的文件描述符、指向用于该缓流冲区的指针、缓冲区的长度、当前在缓冲区中的字节数以及出错标志等。当打开一个流时，标准I/O函数fopen返回一个指向FILE对象的指针。

## 标准输入、标准输出和标准错误

对一个进程预定义了3各流，并且它们可以自动地被进程使用，它们是标准输入、标准输出和标准错误，对应的文件描述符为STDIN\_FILENO、STDOUT\_FILENO、STDERR\_FILENO。这三个标准I/O流可以通过预定义的文件指针stdio、stdout和stderr使用。

## 缓冲

标准I/O库提供缓冲的目的是尽可能减少使用read和write调用的次数，对每个I/O流自动地进行缓冲管理。

标准I/O提供3种类型的缓冲：

* 全缓冲。在填满标准I/O缓冲区后才进行实际I/O操作。对于驻留在磁盘上的文件通常是由标准I/O库实施全缓冲的。在一个流上第一次进行I/O操作时，相关标准I/O函数通常调用malloc获得需使用的缓冲区。标准I/O的写回操作称为冲洗flush，缓冲区可由标准I/O例程自动冲洗（比如缓冲区满），或者使用fflush冲洗一个流。

* 行缓冲。当在输入和输出中遇到换行符时，标准I/O库执行I/O操作。当流涉及一个终端时，通常使用行缓冲。行缓冲有两个限制，第一，因为行缓冲的缓冲区长度有限，当缓冲区被填满还没有遇到一个换行符时，也进行I/O操作；第二，如果输入数据来自内核，则冲洗所有行缓冲输出流。

* 不带缓冲。标准I/O库不对字符进行缓冲存储，即立即进行I/O操作。标准错误流stderr通常是不带缓冲的，这就使得出错信息可以尽快显示出来。

ISO C 要求的缓冲特征：

* 当且仅当标准输入和标准输出并不指向交互式设备时，它们才是全缓冲的。
* 标准错误绝不会是全缓冲的。

大部分系统默认：

* 标准错误是不带缓冲的。
* 若是指向终端设备的流，则是行缓冲的；否则是全缓冲的。

可使用setbuf和setvbuf函数更改缓冲类型。

```cpp
#include<stdio.h>
void setbuf(FILE *restrict fp, char *restrict buf);
void setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);
```

因为函数的参数是文件指针，所以要修改缓冲类型的流要先被打开。

使用setbuf函数打开或关闭缓冲机制。为了带缓冲进行I/O，参数buf必须指向一个长度为BUFSIZ（<stdio.h>）的缓冲区。通常在此之后该流是全缓冲的，若该流与一个终端设备相关，某些系统也将其设置为行缓冲的。将buf设置为NULL来关闭缓冲。

使用setvbuf可以指定缓冲类型，根据mode不同：

* \_IOFBF 全缓冲
* \_IOLBF 行缓冲
* \_IONBF 不带缓冲

如果指定一个不带缓冲的流，则忽略buf和size参数。如果指定全缓冲或行缓冲，则buf和size可选择地指定一个缓冲区及其长度。如果该流是带缓冲的，而buf是NULL，则标准I/O库将自动为该流分配适当长度缓冲区，即一个长度为BUFSIZ的缓冲区。

如果在一个函数内分配一个自动变量类的标准I/O缓冲区，则从该函数返回之前，必须关闭该流。

某些实现将缓冲区的一部分用于存放它自己的管理操作信息，所以可存放在缓冲区中的实际数据字节数少于size。

一般而言，应由系统选择缓冲区长度，并自动分配缓冲区，则当关闭该流时，标准I/O库将自动释放缓冲区。

用fflush冲洗一个流。

```cpp
#include <stdio.h>
int fflush(FILE *fp);
```

若参数fp是NULL，则冲洗所有流。

## 打开流

```cpp
#include <stdio.h>
FILE *fopen(const char *restrict pathname, const char *restrict type);
FILE *freopen(const char *restrict pathname, const char *restrict type,
	      FILE *restrict fp);
FILE *fdopen(int fd, const char *type);
```

* fopen函数打开指定路径名的文件

* freopen函数在一个指定的流上打开一个指定的文件，若该流已打开，则先关闭该流。若该流已定向，则使用freopen清除该定向。次函数一般用于将一个指定的文件打开为一个预定义的流：标准输入，标准输出或标准错误。

* fdopen函数取一个已有的文件描述符，并使一个标准的I/O流与该描述符相结合。次函数常用于创建管道和网络通信通道函数返回的描述符。因为这些特殊类型的文件不能用标准I/O函数fopen打开，所以先调用设备专用函数以获得一个文件描述符，然后用fdopen使一个标准I/O流与该描述符相结合。

type参数值及其意义见下图。

![type参数](http://o877ej38d.bkt.clouddn.com/apue-5.2.PNG)

使用字符b作为type一部分，使得标准I/O系统可区分文本文件和二进制文件。因为UNIX内核并不对这两种文件进行区分，所以在UNIX环境下指定字符b作为type的一部分并无作用。

对于fdopen函数，它不能截断为了写而打开的任一文件，因为已有文件描述符对应的文件已经被打开。

追加类型打开文件，每次写都将数据写到文件的当前尾端处。如果有多个进程用标准I/O追加写方式打开同一个文件，那么来自每个进程的数据都将正确地写到文件中。

当以读写混合的方式打开一个文件时：

* 如果中间没有fflush、fseek、fsetpos或rewind，则在输出的后面不能直接跟随输入
* 如果中间没有fseek、fsetpos或rewind，或者一个输入操作没有到达文件尾端，则在输入操作之后不能直接跟随输出

用fclose关闭一个打开的流。

```cpp
#include <stdio.h>
int fclose(FILE *fp);
```

在文件被关闭之前，冲洗缓冲区中的输出数据，缓冲区中的任何输入数据被丢弃。如果标准I/O库已经为该流自动分配了一个缓冲区，则释放该缓冲区。

当一个进程正常终止时，则所有带未写缓冲数据的标准I/O流都被冲洗，所有打开的标准I/O流都被关闭。

## 读和写流

三种不同类型的非格式化I/O：

* 每次一个字符的I/O。一次读或写一个字符，如果流是带缓冲的，则标准I/O函数处理所有缓冲。
* 每次移行的I/O。每行都以一个换行符结束。读入时应说明能处理的最大长度。
* 直接I/O。读写指定长度的数据。

### 输入函数

以下三个函数一次读入一个字符。

```cpp
#include <stdio.h>
int getc(FILE *fp);
int fgetc(FILE *fp);
int getchar(void);
```

函数getchar等同于getc(stdin)。前两个函数的区别是，getc可被实现为宏，而fgetc不能实现为ie宏，所以：

* getc的参数不应该是表达式，因为它可能被计算多次，即宏替换的副作用。
* 因为fgetc必是一个函数，所以有其地址，可被作为参数传递
* 调用fgetc函数的时间可能比使用getc宏要长

在返回时，将unsigned char类型转换为int类型，无符号使得最高位为1也不会返回负值，这样可以返回所有可能的字负值以及标识出错和到达末尾的指示值。<stdio.h>中定义的EOF被要求是个负值，通常是-1，所以返回值不能保存在一个字符类型中。

不管出错还是到达文件尾端，都返回EOF，可用以下函数区分两种情况。

```cpp
#include <stdio.h>
int ferror(FILE *fp);
int feof(FILE *fp);
coid clearerr(FILE *fp);
```

大多数实现中，为每个流在FILE对象中维护了两个标志：

* 出错标识
* 文件结束标志

clearerr可以清除这两个标志

可以调用ungetc将读取的字符再压回流中。

```cpp
#include <stdio.h>
int ungetc(int c, FILE *fp);
```

压回字符，只是写回标准I/O的流缓冲区中。

回送的字符，不一定是上一次读到的字符。不能回送EOF。但是当已经到达文件尾端时，仍可以回送一个字符。下次读将返回该字符，再读则返回EOF。之所以能这样做的原因是，一次成功的ungetc调用会清除该流的文件结束标志。

### 输出函数

与前述输出函数对应。

```cpp
#include<stdio.h>
int putc(int c, FILE *fp);
int fputc(int c, FILE *fp);
int putchar(int c);
```

putchar等同于putc(c,stdin)，putc可被实现为宏，fputc不能实现为宏。

## 每次一行I/O

```cpp
#include <stdio.h>
char *fgets(char *restrict buf, int n, FILE *restrict fp);
char gets(char *buf);
```

gets从标准输入读，fgets从指定的流读。

fgets必须指定缓冲区长度n。次函数一直读到下一个换行符，放入缓冲区，但是不超过n-1个字符（因为总是在最后放一个null）。fgets会将读到的换行符一起放入缓冲区。若一行包括换行符在内的长度超过n-1，将返回一个不完整的行。

gets是一个危险的函数，因为有溢出风险。gets不将换行符放入缓冲区。

```cpp
#include <stdio.h>
int fput(const char *restrict str, FILE *restrict fp);
int puts(const char *str);
```

fputs见一个以null终止符结尾的字符串写到指定流，终止符不写出，输出中可能不只有一行。

puts将一个以null结尾的字符串写到标准输出，终止符不写出，但是puts会在写完字符串之后，自动写出一个换行符。

## 二进制I/O

使用二进制I/O读写一个结构。

```cpp
#include <stdio.h>
size_t fread(void *restrict ptr, size_t size, size_t nobj, 
	     FILE *restrict fp);
size_t fwrite(const void *restrict ptr, size_t size size_t nobj,
	      FILE *restrict fp);
```

一次读或写nobj个size指定长度的数据。

fread和fwrite返回读或写的对象数。对于读，如果出错或到达文件尾端，则返回值可以少于nobj，此时应调用ferror或feof来判断是哪种情况。对于写，如果返回值少于所要求的nobj，则出错。

在跨系统的处理上，可能因为类型长度、编码和对齐不同等原因造成错误。

## 定位流

```cpp
#include <stdio.h>
long ftell(FILE *fp);
int fseek(FILE *fp, long offset, int whence);
void rewind(FILE *fp);
```

函数ftell返回当前文件位置指示，即当前偏移值。

fseek将流定位到指定位置，whence参数作为参照：

* SEEK\_SET 文件起始位置
* SEEK\_CUR 文件当前位置
* SEEK\_END 文件尾端

函数rewind将流设置到起始位置。

上述函数假设offset可以存放在long只中，下面两个函数offset支持off_t范围。

```cpp
#include <stdio.h>
off_t ftello(FILE *fp);
int fseeko(FILE *fp, off_t offset, int whence);
```

另外两个函数在非UNIX系统上也能使用。fgetpos将文件位置指示器的当前值存入由pos指向的对象中，在以后调用fsetpos时，可以使用此值重新定位至该位置。

## 格式化I/O

### 格式化输出

```cpp
#include <stdio.h>
int printf(const char *restrict format, ...);
int fprintf(FILE *restrict fp, const char *restrict format, ...);
int dprintf(int fd, const char *restrict format, ...);
int sprintf(char *restrict buf, const char *restrict format, ...);
int snprintf(char *restrict buf, size_t n, const char *restrict format, ...);
```

sprintf将格式化的字符送入数组buf中。并在数组的尾端自动加一个null，但该字符不包括在返回值中。sprintf函数可能造成缓冲区溢出。所以有了snprintf函数。若snprintf函数返回小于缓冲区长度n的正值，那么没有截断输出，若发生了一个编码错误，snprinf返回负值。

format格式

%[flags][fldwidth][precision][lenmodifier]convtype

![flags标志](http://o877ej38d.bkt.clouddn.com/apue-5.7.PNG)

fldwidth说明最小字段宽度。转换后参数字符若小于宽度，则多于字符位置用空格填充。字符宽度是一个非负十进制数，或者一个星号。

precision说明整型转换后最少输出数字位数、浮点数转换后小数点后的最少位数、字符串转换后最大字符数。精度是一个点，其后跟随一个可选的非负十进制数或者一个星号。

![lenmodifier长度修饰符](http://o877ej38d.bkt.clouddn.com/apue-5.8.PNG)

![convtype转换类型](http://o877ej38d.bkt.clouddn.com/apue-5.9.PNG)

另外有printf族函数的变体，函数名为前面多一个v，可变参数表（...）替换成了va_list类型的arg参数，需要头文件<stdarg.h>

### 格式化输入

```cpp
#include <stdio.h>
int scanf(const char *restrict format, ...);
int fscanf(FILE *restrict fp, const char *restrict format, ...);
int sscanf(const char *restrict buf, const char *restrict format, ...);
```

转换说明

%[*][fldwidth][m][lenmodifier]convtype

其中\*号的作用是抑制转换，依然解析，但不保存，如对字符串1/2进行%d%\*c%d转换，并在参数表中放置&x,&y，则1和2分别放入x和y变量中，中间的字符类型被解析但被抛弃。

m是赋值分配符，可用于%c、%s和%[转换符，迫使内存缓冲区分配空间以接纳转换字符串。这种情况下，相关参数必须是指针地址，分配的缓冲区地址必须复制给该指针。如果调用成功，该分配的空间由调用者使用free释放。

convtype和printf函数族稍有不同。

![convtype转换类型](http://o877ej38d.bkt.clouddn.com/apue-5.10.PNG)

类似的，scanf函数族也有v开头的变体函数。

scanf函数族和printf函数族都可以使用%n$表示的n个参数，从1开始计数，同一编号的参数在格式串中可引用多次。

## 实现细节

使用fileno函数获得一个流的文件描述符。

```cpp
#include <stdio.h>
int fileno(FILE *fp);
```

如果要调用dup和fcntl等函数，需要此函数。

为了了解特定系统中标准I/O库的实现，应该从头文件<stdio.h>开始。从中可看到FILE对象的定义、每个流标志的定义以及定义为宏的各个标准I/O例程（如getc）。

## 临时文件

创建临时文件。

```cpp
#include <stdio.h>
char *tmpnam(char *ptr);
FILE *tmpfile(void);
```

tmpnam函数产生一个与现有文件名不同的一个有效路径名字符串。每次调用的返回不同，最多调用TMP_MAX（<stdio.h>）次。

* 若ptr是NULL，则所产生的路径名存放在一个静态区中，指向该静态区的指针作为函数返回值。再次调用tmpnam时会重写该静态区，所以应该对返回值进行深拷贝，以免当被覆盖时造成错误。

* 若ptr不是NULL，则认为它应该是指向长度至少是L_tmpnam（<stdio.h>）个字符串的数组，产生的路径名放在该数组中，ptr作为返回值。

tmpfile创建一个临时二进制文件（类型wb+），在关闭该文件或程序结束时自动删除这种文件。它常见的实现是，只用tmpnam返回的路径名创建一个文件，并立即unlink它。

创建指定前缀的临时目录和临时文件。

```cpp
#include <stdlib.h>
char *mkdtemp(char *template);
int mkstemp(char *template);
```

mkdtemp函数创建一个目录，mkstemp创建一个文件，它们的名字都是唯一的。名字是通过template字符串进行选择的，这个字符串后六位设置为XXXXXX，这两个函数将这些占位符替换成不同的字符来构建一个唯一的路径名。若函数成功，则直接修改template字符串为路径名。

mkdtemp函数创建的目录使用权限位：S\_IRUSR | S\_IWUSR | S\_IXUSR。使用屏蔽字可以进一步限制权限。如果目录创建成功，mkdtemp返回新目录名。

mkstemp函数以唯一的名字创建一个普通文件并且打开该文件，该函数返回的文件描述符以读写方式打开，权限位: S\_IRUSR | S\_IWUSR。与tempfile不同，mkstemp创建的临时文件并不会自动删除，需要自己手动unlink。

使用tmpnam后再创建文件是两个函数调用，可能在中间被其他进程创建了同名文件。应该使用原子操作的tmpfile和mkstemp函数。

## 内存流

使用fmemopen函数创建内存流。

```cpp
#include <stdio.h>
FILE *fmemopen(void *restrict buf, size_t size, const char *restrict type);
```

buf参数指向缓冲区的开始位置，size参数指定了缓冲区大小的字节数。如果buf参数为空，fmemopen函数分配size字节数的缓冲区。在这种情况下，当流关闭时缓冲区会被释放。

![内存流type参数](http://o877ej38d.bkt.clouddn.com/apue-5.14.PNG)

注意内存流的type和标准I/O流的type的区别：

* 以追加写方式打开内存流时，当前文件位置设为缓冲区中的第一个null字节。若缓冲区中不存在null，则当前位置设置为缓冲区结尾的后一个字节。当流不是以追加写方式打开时，当前位置设置为缓冲区的开始位置。因为二进制数据中可能包含多个null字节，所以使用内存流时需要注意。

* 如果buf参数时一个null指针，打开流进行读或者写都没有意义。因为此时缓冲区是通过fmemopen进行分配的，没有办法找到缓冲区的地址，只写方式打开流意味着无法读取已写入的数据，同样，以读方式打开流意味着无数据可读。

* 任何时候需要增加流缓冲区中数据量以及调用fclose、fflush、fseek、fseeko以及fsetpos时都会在当前位置写入一个null字节，引发冲洗。

用于创建创建内存流的其他两个函数。

```cpp
#include <stdio.h>
FILE *open_memstream(char **bufp, size_t *sizep);
#include <wchar.h>
FILE *open_wmemstream(wchar_t **bufp, size_t *sizep);
```

open_memstream函数创建的流是面向字节的，open_wmemstream函数创建的流是面向宽字节的。它们与fmemopen函数的不同在于：

* 创建的流只能写打开
* 不能指定自己的缓冲区，但可以分别通过bufp和sizep参数访问缓冲区地址和大小
* 关闭流后需要自行释放缓冲区
* 对流添加字节会增加缓冲区大小

在缓冲区地址和大小的使用上有一些原则：

* 缓冲区地址和长度只有在调用fclose或fflush后才有效
* 这些值只有在下一次流写入或调用fclose前才有效

因为缓冲区可以增长，可能需要重新分配。如果出现这种情况，我们会发现缓冲区的内存地址值在下一次调用fclose或fflush时会改变。
