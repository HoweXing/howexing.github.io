---
title: UNIX标准I/O库
date: 2016-06-18 09:05:00
tags:
  - C
  - UNIX
---
## 流和FILE对象

文件I/O中，当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后续的I/O操作。而对于标准I/O库，它们的操作是围绕流进行的，当使用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。

标准I/O文件流可以用于单字节或多字节（宽）字符集。流的定向决定了所读写的字符是单字节还是多字节的。一个流被创建时是没有定向的，若在未定向的流上使用多字节I/O函数，则将该流的定向设置为宽定向的；若在未定向的流上使用单字节I/O函数，则将该流的定向设置为字节定向的。

有两个函数可以改变流的定向。freopen函数清除一个流的定向，fwide函数设置流的定向。

```cpp
#include <stdio.h>
#include <wchar.h>
int fwide(FILE *fp, int mode);
```
<!--more-->
根据mode参数值不同:

* 若mode为负，fwide将试图设置该流为字节定向
* 若mode为正，fwide将试图设置该流为宽定向
* 若mode为零，fwide仅返回流的当前定向（负为字节定向，正为宽定向，零为未定向）

fwide没有返回值表示出错的情况，所以在调用fwide之前，清除errno，返回后检查errno。

FILE是一个结构，包含了标准I/O库为管理流需要的所有信息，包括用于实际I/O的文件描述符、指向用于该缓流冲区的指针、缓冲区的长度、当前在缓冲区中的字节数以及出错标志等。当打开一个流时，标准I/O函数fopen返回一个指向FILE对象的指针。

## 标准输入、标准输出和标准错误

对一个进程预定义了3各流，并且它们可以自动地被进程使用，它们是标准输入、标准输出和标准错误，对应的文件描述符为STDIN\_FILENO、STDOUT\_FILENO、STDERR\_FILENO。这三个标准I/O流可以通过预定义的文件指针stdio、stdout和stderr使用。

## 缓冲

标准I/O库提供缓冲的目的是尽可能减少使用read和write调用的次数，对每个I/O流自动地进行缓冲管理。

标准I/O提供3种类型的缓冲：

* 全缓冲。在填满标准I/O缓冲区后才进行实际I/O操作。对于驻留在磁盘上的文件通常是由标准I/O库实施全缓冲的。在一个流上第一次进行I/O操作时，相关标准I/O函数通常调用malloc获得需使用的缓冲区。标准I/O的写回操作称为冲洗flush，缓冲区可由标准I/O例程自动冲洗（比如缓冲区满），或者使用fflush冲洗一个流。

* 行缓冲。当在输入和输出中遇到换行符时，标准I/O库执行I/O操作。当流涉及一个终端时，通常使用行缓冲。行缓冲有两个限制，第一，因为行缓冲的缓冲区长度有限，当缓冲区被填满还没有遇到一个换行符时，也进行I/O操作；第二，如果输入数据来自内核，则冲洗所有行缓冲输出流。

* 不带缓冲。标准I/O库不对字符进行缓冲存储，即立即进行I/O操作。标准错误流stderr通常是不带缓冲的，这就使得出错信息可以尽快显示出来。

ISO C 要求的缓冲特征：

* 当且仅当标准输入和标准输出并不指向交互式设备时，它们才是全缓冲的。
* 标准错误绝不会是全缓冲的。

大部分系统默认：

* 标准错误是不带缓冲的。
* 若是指向终端设备的流，则是行缓冲的；否则是全缓冲的。

可使用setbuf和setvbuf函数更改缓冲类型。

```cpp
#include<stdio.h>
void setbuf(FILE *restrict fp, char *restrict buf);
void setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);
```

因为函数的参数是文件指针，所以要修改缓冲类型的流要先被打开。

使用setbuf函数打开或关闭缓冲机制。为了带缓冲进行I/O，参数buf必须指向一个长度为BUFSIZ（<stdio.h>）的缓冲区。通常在此之后该流是全缓冲的，若该流与一个终端设备相关，某些系统也将其设置为行缓冲的。将buf设置为NULL来关闭缓冲。

使用setvbuf可以指定缓冲类型，根据mode不同：

* \_IOFBF 全缓冲
* \_IOLBF 行缓冲
* \_IONBF 不带缓冲

如果指定一个不带缓冲的流，则忽略buf和size参数。如果指定全缓冲或行缓冲，则buf和size可选择地指定一个缓冲区及其长度。如果该流是带缓冲的，而buf是NULL，则标准I/O库将自动为该流分配适当长度缓冲区，即一个长度为BUFSIZ的缓冲区。

如果在一个函数内分配一个自动变量类的标准I/O缓冲区，则从该函数返回之前，必须关闭该流。

某些实现将缓冲区的一部分用于存放它自己的管理操作信息，所以可存放在缓冲区中的实际数据字节数少于size。

一般而言，应由系统选择缓冲区长度，并自动分配缓冲区，则当关闭该流时，标准I/O库将自动释放缓冲区。

用fflush冲洗一个流。

```cpp
#include <stdio.h>
int fflush(FILE *fp);
```

若参数fp是NULL，则冲洗所有流。

## 打开流

```cpp
#include <stdio.h>
FILE *fopen(const char *restrict pathname, const char *restrict type);
FILE *freopen(const char *restrict pathname, const char *restrict type,
	      FILE *restrict fp);
FILE *fdopen(int fd, const char *type);
```

* fopen函数打开指定路径名的文件

* freopen函数在一个指定的流上打开一个指定的文件，若该流已打开，则先关闭该流。若该流已定向，则使用freopen清除该定向。次函数一般用于将一个指定的文件打开为一个预定义的流：标准输入，标准输出或标准错误。

* fdopen函数取一个已有的文件描述符，并使一个标准的I/O流与该描述符相结合。次函数常用于创建管道和网络通信通道函数返回的描述符。因为这些特殊类型的文件不能用标准I/O函数fopen打开，所以先调用设备专用函数以获得一个文件描述符，然后用fdopen使一个标准I/O流与该描述符相结合。

type参数值及其意义见下图。

![type参数](http://o877ej38d.bkt.clouddn.com/apue-5.2.PNG)

使用字符b作为type一部分，使得标准I/O系统可区分文本文件和二进制文件。因为UNIX内核并不对这两种文件进行区分，所以在UNIX环境下指定字符b作为type的一部分并无作用。

对于fdopen函数，它不能截断为了写而打开的任一文件，因为已有文件描述符对应的文件已经被打开。

追加类型打开文件，每次写都将数据写到文件的当前尾端处。如果有多个进程用标准I/O追加写方式打开同一个文件，那么来自每个进程的数据都将正确地写到文件中。

当以读写混合的方式打开一个文件时：

* 如果中间没有fflush、fseek、fsetpos或rewind，则在输出的后面不能直接跟随输入
* 如果中间没有fseek、fsetpos或rewind，或者一个输入操作没有到达文件尾端，则在输入操作之后不能直接跟随输出

用fclose关闭一个打开的流。

```cpp
#include <stdio.h>
int fclose(FILE *fp);
```

在文件被关闭之前，冲洗缓冲区中的输出数据，缓冲区中的任何输入数据被丢弃。如果标准I/O库已经为该流自动分配了一个缓冲区，则释放该缓冲区。

当一个进程正常终止时，则所有带未写缓冲数据的标准I/O流都被冲洗，所有打开的标准I/O流都被关闭。

## 读和写流

三种不同类型的非格式化I/O：

* 每次一个字符的I/O。一次读或写一个字符，如果流是带缓冲的，则标准I/O函数处理所有缓冲。
* 每次移行的I/O。每行都以一个换行符结束。读入时应说明能处理的最大长度。
* 直接I/O。读写指定长度的数据。

### 输入函数

以下三个函数一次读入一个字符。

```cpp
#include <stdio.h>
int getc(FILE *fp);
int fgetc(FILE *fp);
int getchar(void);
```

函数getchar等同于getc(stdin)。前两个函数的区别是，getc可被实现为宏，而fgetc不能实现为ie宏，所以：

* getc的参数不应该是表达式，因为它可能被计算多次，即宏替换的副作用。
* 因为fgetc必是一个函数，所以有其地址，可被作为参数传递
* 调用fgetc函数的时间可能比使用getc宏要长

在返回时，将unsigned char类型转换为int类型，无符号使得最高位为1也不会返回负值，这样可以返回所有可能的字负值以及标识出错和到达末尾的指示值。<stdio.h>中定义的EOF被要求是个负值，通常是-1，所以返回值不能保存在一个字符类型中。

不管出错还是到达文件尾端，都返回EOF，可用以下函数区分两种情况。

```cpp
#include <stdio.h>
int ferror(FILE *fp);
int feof(FILE *fp);
coid clearerr(FILE *fp);
```

大多数实现中，为每个流在FILE对象中维护了两个标志：

* 出错标识
* 文件结束标志

clearerr可以清除这两个标志

可以调用ungetc将读取的字符再压回流中。

```cpp
#include <stdio.h>
int ungetc(int c, FILE *fp);
```

压回字符，只是写回标准I/O的流缓冲区中。

回送的字符，不一定是上一次读到的字符。不能回送EOF。但是当已经到达文件尾端时，仍可以回送一个字符。下次读将返回该字符，再读则返回EOF。之所以能这样做的原因是，一次成功的ungetc调用会清除该流的文件结束标志。

### 输出函数

与前述输出函数对应。

```cpp
#include<stdio.h>
int putc(int c, FILE *fp);
int fputc(int c, FILE *fp);
int putchar(int c);
```

putchar等同于putc(c,stdin)，putc可被实现为宏，fputc不能实现为宏。

## 每次一行I/O

```cpp
#include <stdio.h>
char *fgets(char *restrict buf, int n, FILE *restrict fp);
char gets(char *buf);
```

gets从标准输入读，fgets从指定的流读。

fgets必须指定缓冲区长度n。次函数一直读到下一个换行符，放入缓冲区，但是不超过n-1个字符（因为总是在最后放一个null）。fgets会将读到的换行符一起放入缓冲区。若一行包括换行符在内的长度超过n-1，将返回一个不完整的行。

gets是一个危险的函数，因为有溢出风险。gets不将换行符放入缓冲区。

```cpp
#include <stdio.h>
int fput(const char *restrict str, FILE *restrict fp);
int puts(const char *str);
```

fputs见一个以null终止符结尾的字符串写到指定流，终止符不写出，输出中可能不只有一行。

puts将一个以null结尾的字符串写到标准输出，终止符不写出，但是puts会在写完字符串之后，自动写出一个换行符。

## 二进制I/O

使用二进制I/O读写一个结构。

```cpp
#include <stdio.h>
size_t fread(void *restrict ptr, size_t size, size_t nobj, 
	     FILE *restrict fp);
size_t fwrite(const void *restrict ptr, size_t size size_t nobj,
	      FILE *restrict fp);
```

一次读或写nobj个size指定长度的数据。

fread和fwrite返回读或写的对象数。对于读，如果出错或到达文件尾端，则返回值可以少于nobj，此时应调用ferror或feof来判断是哪种情况。对于写，如果返回值少于所要求的nobj，则出错。

在跨系统的处理上，可能因为类型长度、编码和对齐不同等原因造成错误。

## 定位流

```cpp
#include <stdio.h>
long ftell(FILE *fp);
int fseek(FILE *fp, long offset, int whence);
void rewind(FILE *fp);
```

函数ftell返回当前文件位置指示，即当前偏移值。

fseek将流定位到指定位置，whence参数作为参照：

* SEEK\_SET 文件起始位置
* SEEK\_CUR 文件当前位置
* SEEK\_END 文件尾端

函数rewind将流设置到起始位置。

上述函数假设offset可以存放在long只中，下面两个函数offset支持off_t范围。

```cpp
#include <stdio.h>
off_t ftello(FILE *fp);
int fseeko(FILE *fp, off_t offset, int whence);
```

另外两个函数在非UNIX系统上也能使用。fgetpos将文件位置指示器的当前值存入由pos指向的对象中，在以后调用fsetpos时，可以使用此值重新定位至该位置。

## 格式化I/O

```cpp
#include <stdio.h>
int printf(const char *restrict format, ...);
int fprintf(FILE *restrict fp, const char *restrict format, ...);
int dprintf(int fd, const char *restrict format, ...);
int sprintf(char *restrict buf, const char *restrict format, ...);
int snprintf(char *restrict buf, size_t n, const char *restrict format, ...);
```

sprintf将格式化的字符送入数组buf中。并在数组的尾端自动加一个null，但该字符不包括在返回值中。sprintf函数可能造成缓冲区溢出。所以有了snprintf函数。若snprintf函数返回小于缓冲区长度n的正值，那么没有截断输出，若发生了一个编码错误，snprinf返回负值。

format格式

%[flags][fldwidth][precision][lenmodifier]convtype

![flags标志](http://o877ej38d.bkt.clouddn.com/apue-5.7.PNG)

fldwidth说明最小字段宽度。转换后参数字符若小于宽度，则多于字符位置用空格填充。字符宽度是一个非负十进制数，或者一个星号。

precision说明整型转换后最少输出数字位数、浮点数转换后小数点后的最少位数、字符串转换后最大字符数。精度是一个点，其后跟随一个可选的非负十进制数或者一个星号。

![lenmodifier长度修饰符](http://o877ej38d.bkt.clouddn.com/apue-5.8.PNG)

![convtype转换类型](http://o877ej38d.bkt.clouddn.com/apue-5.9.PNG)
