---
title: Unix文件I/O
date: 2016-06-02 22:53:48
tags: 
  - unix
  - c
---
Unix系统的文件I/O及函数调用。

## 文件描述符

文件描述符是一个非负整数，又内核分配，函数open和creat返回文件描述符，函数read和write需要文件描述符作为参数。

在Unix系统中，文件描述符0，1，2有代表特殊的I/O：

* 0 \- 标准输入（stdin）
* 1 \- 标准输出（stdout）
* 2 \- 标准错误（stderr）

文件描述符的上限又操作系统的OPEN\_MAX标识，表示一个进程最多能打开的文件个数，相应的文件描述符范围为 0\-OPEN\_MAX-1。

## 函数open和openat

```cpp
#include <fcntl.h>
int open(const char *path, int oflag, ... /* mode_t mode */);
int openat(int fd, const char *path, int oflag, ... /* mode_t mode */);
```

打开文件，并以当前最小可用文件描述符返回。

带有at的函数一般是对应不带at的函数的相对路径版本，作为参照物的就是带有at函数的第一个参数（文件描述符），在文件IO的函数集中有很多这样的函数对。

对于带有at的函数，有三种可能性：

* path是绝对路径，fd被忽略，和不带at的函数效果相同
* path是相对路径，则相对于fd所指示的目录，如果fd是AT_FDCWD，则相对于当前工作目录
<!--more-->

添加带有at的文件I/O函数，有两个目的：

1. 让进程内部线程可以使用相对路径打开目录中的文件，而不再只能打开当前工作目录
2. 避免time\-of\-check\-to\-time错误，这是一种漏洞，比如在检查文件和使用文件的非原子操作之间替换掉原始文件

若\_POSIX\_NO\_TRUNC有效，则当路径名长度超过PATH\_MAX或路径中任意文件名长度超过NAME\_MAX时，出错返回，并设errno为ENAMETOOLONG，可以使用fpathconf或pathconf来查看\_POSIX\_NO\_TRUNC状态。

## 函数creat

```cpp
#include <fcntl.h>
int creat(const char *path, mode_t mode);
```

该函数相当于设置了对应oflag参数的open函数

```cpp
open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);
```

对于creat函数，不足之处是WRONLY，如果要既写又读文件，则需要先close再次open，其实这种需求可以用open函数设置合适oflag参数达成

```cpp
open(path, O_RDWR | O_CREAT | O_TRUNC, mode);
```

## 函数close

```cpp
#include<unistd.h>
int close(int fd);
```

关闭文件时会释放该进程加在该文件上的所有记录锁。

当进程终止时，它打开的所有文件都会被内核关闭。

## 函数lseek

```cpp
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);
```

进程打开的每个文件都有对应的文件偏移量，通常为非负整数。打开文件时一般是从偏移量0开始，若指定O\_APPEND，则偏移量为文件长度。

根据wherece不同情况：

* SEEK\_SET 相对文件开始的偏移量，offset为正（某些系统允许负偏移）
* SEEK\_CUR 相对当前位置的偏移量，offset可正可负
* SEEK\_END 相对结尾位置的偏移量，offset可正可负

因为lseek成功时返回当前偏移量，可以使用

```cpp
off_t currpos = lseek(fd, 0, SEEK_CUR);
```

获得当前文件偏移量。

当偏移后超过当前文件长度时，将形成空洞，空洞并不在磁盘上占用存储区，若打印时则会以0x00表示这部分的值，虽然它们在磁盘上并不存在。

对于描述符指向管道、FIFO或套接字时，lseek返回-1，并置errno为ESPIPE。因为当前偏移值可能为负值，所以不能以lseek的返回值作为判断成功与否的依据，应看errno的情况。

off_t是32为有符号整型，所以只能操纵2G以内的文件，如果需要操作大文件，需要使用64位版本函数。

## 函数read

```cpp
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t nbytes);
```

read成功时返回读取字节数，到结尾则返回0，出错返回-1。

实际读取长度（read返回值）可能小于作为参数传入的nbytes的值，因为：

* 文件要看结尾之前还剩多少字节
* 终端设备一次可能只能读一行
* 网络缓冲可读字节数
* 管道和FIFO当前可读字节数
* 磁带等面向记录的设备一次只能读一个记录
* 信号导致中断

## 函数write

```cpp
#include <unistd,h>
ssize_t write(int fd, const void *buf, size_t1 nbytes);
```

write的返回值和nbytes相同表示成功，否则就是出错，出错原因时磁盘已满或超过了该进程的文件长度限制。write成功之后，文件偏移量增加实际写的字节数。

## I/O的效率

预读技术被用来该神性能，当检测到正在顺序读取时，系统就试图读入比应用所要求的更多数据。

## 文件共享

nix系统支持在不同进程间共享打开文件。对于一个进程，在进程表中有该进程的记录项，记录项中包含一张打开文件表，打开文件表的每一项对应一个打开文件，每一项有一个文件指针指向一个文件表项。文件表项中有文件状态标志（读、写等），当前文件偏移量（lseek用到的），又指向一个v节点，v节点又包含i节点。

下图中显示了fd为0和1的两个文件，即标准输入和标准输出。

![打开文件表数据结构](http://o877ej38d.bkt.clouddn.com/apue-3.7.PNG)

若有两个进程，A进程在fd 3上打开一文件，B进程在fd 4上打开同一个文件，则其文件打开表的数据结构如下。两个进程各有一个文件表项，指向同一个v节点。

![文件共享](http://o877ej38d.bkt.clouddn.com/apue-3.8.PNG)

之所以每个进程都获得自己的文件表项，是因为可以使每个进程都有它自己的对该文件的当前偏移量。

可能有多个文件描述符项指向同一文件表项，dup和fork导致这一结果，其中fork是父子进程各自的每一个打开文件描述符共享同一个文件表项。

注意：

* 文件描述符标志只用于一个进程的一个描述符
* 文件状态标志则应用于指向该给定文件表项的任何进程中的所有描述符

## 原子操作

### 追加到一个文件

向文件末尾添加数据，如果先lseek再write，这就使用了两个函数调用，而现今的操作系统都是多任务的，若A进程lseek到了文件D的末尾，想要开始写100字节，写之前因为种种原因，A进程挂起，B进程开始，而B进程同样要写D文件，注意D文件到现在还没有被改动过，所以B进程lseek到末尾开始了write，完成后退出，此时A进程又被调度，A进程此时处于lseek完毕要write的状态，而它想当然地以为它的D文件当前偏移量正好是D文件的末尾，实时是D文件已经被B进程加长了，此时A进程的write就改动了B进程刚写入的内容。

造成这种情况的原因就是，两个分离的函数调用不是原子操作，可能随时被中途挂起。对于追加文件这种，在打开文件时设置O\_APPEND，这样在每一次write之前，内核都将把当前文件偏移量设置到当前文件末尾。

### 函数pread和pwrite

```cpp
#include <unistd.h>
ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);
ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);
```

pread相当于lseek跟read，pwrite相当于lseek跟write，其区别为在pread和pwrite期间：

* 无法中断其定位和读或写操作
* 不更新当前文件偏移量

### 创建一个文件

使用open并设置O\_CREAT和O\_EXCL就可以原子地判断文件是否存在，存在时open失败，不存在时创建文件。

如果没有上述功能，使用设置O\_WRONLY设置的open加上creat来实现同样的逻辑时，可能中途被挂起，导致别的进程新创建的文件被覆盖。

## 函数dup和dup2

```cpp
#include <unistd.h>
int dup(int fd);
int dup2(int fd, int fd2);
```

dup使用另外一个文件描述符，它和fd共享文件表项，并返回这个新的文件描述符，它总是最小可用的文件描述符。

dup2使用fd2设置新描述符的值。如果fd2已经打开，则先关闭它。若fd等于fd2，则返回fd2，而不关闭它。否则fd2的FD\_CLOEXEC文件描述符标志被清除，这样fd2在进程调用exec时是打开状态。

下图表示的是dup(1)的情况，假设3是当前最小可用的文件描述符。

![dup(1)](http://o877ej38d.bkt.clouddn.com/apue-3.9.PNG)

每个文件描述符都有其自己的一套文件描述符标志，新描述符的执行时关闭（close\-on\-exec）标志总是由dup函数清除。

复制一个描述符还可以用fcntl函数，下面两组函数功能上是相同的。

```cpp
dup(fd);
//和
fcntl(fd, F_DUPFD, 0);
```

```cpp
dup2(fd, fd2);
//和
close(fd2);
fcntl(fd, F_DUPFD, fd2);
```

后一组有两处不同：

* dup2是原子操作，close和fcntl是两个函数调用
* dup2和fcntl在errno上不同

## 函数sync、fsync和fdatasync

因为I/O缓冲区的存在，写入的文件并不是立即写到磁盘中，当缓冲区被复用时，已更改过的文件才被写回磁盘，或者使用这三个函数来将缓冲区写回。

```cpp
#include <unistd.h>
int fsync(int fd);
int fdatasync(int fd);
void sync(void);
```

sync只是将所有修改过的块缓冲区排入写队列，然后就返回，不等待磁盘写操作完成。一般守护进程update周期性地调用sync函数来定期冲洗缓冲区。

fsync只对文件描述符fd指定的文件起作用，并等待到磁盘写完成才返回。一般数据库程序使用fsync函数，来保证修改过的块立即写到磁盘上。

fdatasync函数类似于fsync函数，区别在于fdatasync仅影响文件的数据部分，而fsync还会同步更新文件的属性。

## 函数fcntl

fcntl函数可以改变已经打开文件的属性。

```cpp
#include <fcntl.h>
int fcntl(int fd, int cmd, ... /* int arg */);
```

fcntl有5种功能：

* 复制一个已有的描述符（cmd = F\_DUPFD或F\_DUPFD\_CLOEXEC）。复制fd，返回大于等于arg的最小可用文件描述符。对于设置还是清除新文件描述符的FD\_CLOEXEC标志，在于使用从的cmd是F\_DUPFD（清除）还是F\_DUPFD\_CLOEXEC（设置）。

* 获取/设置文件描述符标志（cmd = F\_GETFD或F\_SETFD）。F\_GETFD时返回文件描述符fd的标志。F\_SETFD时将文件描述符fd的标志设置为arg。

* 获取/设置文件状态标志（cmd = F\_GETFL或F\_SETFD）。即获取/设置读写模式和同步策略这些。

* 获取/设置异步I/O所有权（cmd = F\_GETOWN或F\_SETOWN）。获取/设置接受SIGIO和SIGURG信号的进程ID或进程组ID。正的arg指定一个进程ID，负的arg表示等于arg绝对值的一个进程组ID。

* 获取/设置记录锁（cmd = F\_GETLK、F\_SETLK或F\_SETLKW）。

## 函数ioctl

I/O操作不能用上面函数完成的功能通常都可以用ioctl表示，最常用于终端I/O。

```cpp
#include <unistd.h>	/* System V */
#include <sys/ioctl.h>	/* BSD and Linux */
int ioctl(int fd, int request, ...);
```

## /dev/fd

打开dev/fd/n对应文件等效于复制描述符n（若n是打开的）。

```cpp
fd = open("/dev/fd/0",mode);
fd = dup(0);
```

是等价的，0和fd共享同一文件表项。若0先前被打开为只读，那么也只能对fd进行读操作，就算下面这个语句执行是成功的

```cpp
fd = open("/dev/fd/0",O_RDWR);
```

仍然只能对fd进行读操作。

可以使用/dev/fd作为路径名调用creat，这与open时用O\_CREAT是一样的。
